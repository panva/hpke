<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@panva/hpke Browser Test Suite</title>
    <script type="importmap">
      {
        "imports": {
          "@panva/hpke": "./index.js",
          "@panva/hpke-noble": "./examples/noble-suite/index.js",
          "@noble/": "./node_modules/@noble/",
          "./examples/noble-suite/kem.ts": "./examples/noble-suite/kem.js",
          "./examples/noble-suite/aead.ts": "./examples/noble-suite/aead.js",
          "./examples/noble-suite/kdf.ts": "./examples/noble-suite/kdf.js",
          "./index.ts": "./index.js",
          "bowser": "https://cdn.jsdelivr.net/npm/bowser@2/+esm"
        }
      }
    </script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          sans-serif;
        padding: 20px;
        background: rgb(13, 17, 23);
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgb(22, 27, 34);
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        padding: 30px;
      }

      h1 {
        color: #e6edf3;
        margin-bottom: 10px;
        font-size: 32px;
      }

      h1 a {
        color: #8b949e;
        text-decoration: none;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .subtitle {
        color: #8b949e;
        margin-bottom: 30px;
        font-size: 16px;
      }

      .summary {
        margin-bottom: 30px;
      }

      .algorithm-section {
        margin-bottom: 25px;
      }

      .algorithm-section h3 {
        font-size: 18px;
        color: #e6edf3;
        margin-bottom: 12px;
        font-weight: 600;
      }

      .algorithm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
      }

      .algo-card {
        padding: 12px;
        border-radius: 6px;
        border: 2px solid;
        font-size: 13px;
        font-family: 'Monaco', 'Courier New', monospace;
        transition: all 0.2s ease;
      }

      .algo-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .algo-card.native {
        background: rgba(46, 160, 67, 0.15);
        border-color: #3fb950;
        color: #7ee787;
      }

      .algo-card.noble {
        background: rgba(56, 139, 253, 0.15);
        border-color: #388bfd;
        color: #79c0ff;
      }

      .algo-card.unsupported {
        background: rgba(248, 81, 73, 0.15);
        border-color: #f85149;
        color: #ff7b72;
      }

      .algo-card.pending {
        background: rgba(110, 118, 129, 0.1);
        border-color: #30363d;
        color: #8b949e;
      }

      .algo-card.testing {
        background: rgba(187, 128, 9, 0.15);
        border-color: #bb8009;
        color: #f0b72f;
      }

      .algo-card {
        position: relative;
      }

      .algo-card .algo-name {
        font-weight: 600;
        margin-bottom: 4px;
        word-break: break-word;
      }

      .algo-card .algo-status {
        font-size: 11px;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .algo-card .checkmark {
        position: absolute;
        bottom: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #3fb950;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        line-height: 1;
      }

      .test-grid {
        display: grid;
        gap: 15px;
      }

      .test-item {
        border: 2px solid #30363d;
        border-radius: 8px;
        padding: 15px;
        transition: all 0.3s ease;
        background: rgb(13, 17, 23);
      }

      .test-item.running {
        border-color: #bb8009;
        background: rgba(187, 128, 9, 0.1);
        animation: pulse 1.5s ease-in-out infinite;
      }

      .test-item.passed {
        border-color: #3fb950;
        background: rgba(46, 160, 67, 0.1);
      }

      .test-item.failed {
        border-color: #f85149;
        background: rgba(248, 81, 73, 0.1);
      }

      .test-item.expected {
        border-color: #6e7681;
        background: rgba(110, 118, 129, 0.1);
      }

      .test-item.passed-unexpected {
        border-color: #58a6ff;
        background: rgba(56, 139, 253, 0.1);
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
      }

      .test-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .test-name {
        font-weight: 600;
        font-size: 16px;
        color: #e6edf3;
        font-family: 'Monaco', 'Courier New', monospace;
        word-break: break-word;
        overflow-wrap: break-word;
        flex: 1;
        min-width: 0;
      }

      .test-status {
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .test-status.pending {
        background: #e0e0e0;
        color: #666;
      }

      .test-status.running {
        background: #ffc107;
        color: #000;
      }

      .test-status.passed {
        background: #28a745;
        color: white;
      }

      .test-status.failed {
        background: #dc3545;
        color: white;
      }

      .test-status.expected {
        background: #6c757d;
        color: white;
      }

      .test-status.passed-unexpected {
        background: #17a2b8;
        color: white;
      }

      .test-details {
        font-size: 13px;
        color: #8b949e;
        margin-bottom: 8px;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .test-error {
        margin-top: 10px;
        padding: 10px;
        background: rgba(248, 81, 73, 0.15);
        border-left: 4px solid #f85149;
        border-radius: 4px;
        font-size: 13px;
        color: #ff7b72;
        font-family: 'Monaco', 'Courier New', monospace;
        overflow-x: auto;
      }

      .test-duration {
        font-size: 12px;
        color: #6e7681;
        margin-top: 5px;
      }

      .expected-failure {
        display: inline-block;
        margin-left: 8px;
        padding: 2px 8px;
        background: #6c757d;
        color: white;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .loader {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #ffc107;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .filter-buttons {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .filter-btn {
        padding: 8px 16px;
        border: 2px solid #30363d;
        background: rgb(13, 17, 23);
        color: #e6edf3;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s ease;
      }

      .filter-btn:hover {
        background: #30363d;
        border-color: #6e7681;
      }

      .filter-btn.active {
        background: #388bfd;
        color: white;
        border-color: #388bfd;
      }

      .hidden {
        display: none;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>
        @panva/hpke Browser Test Suite
        <a href="https://github.com/panva/hpke" target="_blank">ðŸ”—</a>
      </h1>
      <p class="subtitle">Testing all KEM, KDF, and AEAD implementations in your browser</p>

      <div class="summary" id="summary"></div>

      <div class="filter-buttons hidden">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="native">Native</button>
        <button class="filter-btn" data-filter="noble">extensibility</button>
        <button class="filter-btn" data-filter="passed">Passed</button>
        <button class="filter-btn" data-filter="passed-unexpected">Passed (Unexpected)</button>
        <button class="filter-btn" data-filter="failed-expected">Failed (Expected)</button>
        <button class="filter-btn" data-filter="failed-unexpected">Failed (Unexpected)</button>
        <button class="filter-btn" data-filter="pending">Pending</button>
      </div>

      <div class="test-grid hidden" id="testGrid"></div>
    </div>

    <script type="module">
      import * as HPKE from '@panva/hpke'
      import * as Noble from '@panva/hpke-noble'
      import Bowser from 'bowser'

      import vectors from './test/vectors.json' with { type: 'json' }
      import vectorsPq from './test/vectors-pq.json' with { type: 'json' }
      const allVectors = [...vectors, ...vectorsPq].filter((v) => {
        if (v.mode !== 0x00 && v.mode !== 0x01) return false
        return true
      })

      // ============================================================================
      // ALGORITHM DISCOVERY
      // ============================================================================
      // Dynamically extract all algorithms from HPKE and Noble libraries based on
      // name prefixes (KEM_, KDF_, AEAD_)

      /** Extracts algorithms from a library object by prefix */
      function extractAlgorithms(library, prefix, label, isNoble = false) {
        return Object.keys(library)
          .filter((key) => key.startsWith(prefix))
          .map((name) => ({
            name,
            displayName: `[${label}] ${name}`,
            factory: library[name],
            isNoble,
          }))
          .sort((a, b) => a.name.localeCompare(b.name))
      }

      // Extract native HPKE algorithms
      const KEMS = extractAlgorithms(HPKE, 'KEM_', 'native')
      const KDFS = extractAlgorithms(HPKE, 'KDF_', 'native')
      const AEADS = extractAlgorithms(HPKE, 'AEAD_', 'native')

      // Extract Noble (extensibility) algorithms
      const NOBLE_KEMS = extractAlgorithms(Noble, 'KEM_', 'extensibility', true)
      const NOBLE_KDFS = extractAlgorithms(Noble, 'KDF_', 'extensibility', true)
      const NOBLE_AEADS = extractAlgorithms(Noble, 'AEAD_', 'extensibility', true)

      // Combine native and Noble implementations
      const ALL_KEMS = [...KEMS, ...NOBLE_KEMS]
      const ALL_KDFS = [...KDFS, ...NOBLE_KDFS]
      const ALL_AEADS = [...AEADS, ...NOBLE_AEADS]

      // ============================================================================
      // ALGORITHM ID MAPPINGS
      // ============================================================================
      // Static mapping of algorithm names to their IDs from the HPKE specification

      const ALGORITHM_IDS = {
        // KEMs
        KEM_DHKEM_P256_HKDF_SHA256: 0x0010,
        KEM_DHKEM_P384_HKDF_SHA384: 0x0011,
        KEM_DHKEM_P521_HKDF_SHA512: 0x0012,
        KEM_DHKEM_X25519_HKDF_SHA256: 0x0020,
        KEM_DHKEM_X448_HKDF_SHA512: 0x0021,
        KEM_ML_KEM_512: 0x0040,
        KEM_ML_KEM_768: 0x0041,
        KEM_ML_KEM_1024: 0x0042,
        KEM_MLKEM768_P256: 0x0050,
        KEM_MLKEM1024_P384: 0x0051,
        KEM_MLKEM768_X25519: 0x647a,

        // KDFs
        KDF_HKDF_SHA256: 0x0001,
        KDF_HKDF_SHA384: 0x0002,
        KDF_HKDF_SHA512: 0x0003,
        KDF_SHAKE128: 0x0010,
        KDF_SHAKE256: 0x0011,
        KDF_TurboSHAKE128: 0x0012,
        KDF_TurboSHAKE256: 0x0013,

        // AEADs
        AEAD_AES_128_GCM: 0x0001,
        AEAD_AES_256_GCM: 0x0002,
        AEAD_ChaCha20Poly1305: 0x0003,
        AEAD_EXPORT_ONLY: 0xffff,
      }

      // ============================================================================
      // BASELINE CONFIGURATION
      // ============================================================================
      // When testing a specific component (e.g., a KEM), we pair it with baseline
      // KDF and AEAD to isolate the test. These are the baseline algorithms.

      const baselineKEM = KEMS.find((k) => k.name === 'KEM_DHKEM_P256_HKDF_SHA256')
      const baselineKDF = KDFS.find((k) => k.name === 'KDF_HKDF_SHA256')
      const baselineAEAD = AEADS.find((a) => a.name === 'AEAD_AES_128_GCM')

      // ============================================================================
      // BROWSER COMPATIBILITY
      // ============================================================================
      // Some algorithms are not supported in browsers due to missing Web Crypto APIs
      // Noble implementations provide fallbacks for these
      // Browser-specific unsupported algorithms based on Web Crypto API availability

      /** Detects the current browser engine and version */
      function detectBrowser() {
        const browser = Bowser.getParser(navigator.userAgent)
        return {
          engine: browser.getEngineName(),
          version: parseInt(browser.getBrowserVersion()),
        }
      }

      const unsupported = {
        kem: [
          'KEM_DHKEM_X448_HKDF_SHA512',
          'KEM_ML_KEM_512',
          'KEM_ML_KEM_768',
          'KEM_ML_KEM_1024',
          'KEM_MLKEM768_X25519',
          'KEM_MLKEM768_P256',
          'KEM_MLKEM1024_P384',
        ],
        kdf: ['KDF_SHAKE128', 'KDF_SHAKE256'],
        aead: ['AEAD_ChaCha20Poly1305'],
      }

      const browser = detectBrowser()

      switch (true) {
        case browser.engine === 'Gecko' && browser.version < 143:
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1932396
          unsupported.kem.push('KEM_DHKEM_X25519_HKDF_SHA256')
          break
      }

      /**
       * Determines if a test is expected to fail based on browser support Noble implementations are
       * always expected to work (they provide fallbacks)
       */
      function isExpectedToFail(test) {
        // Noble implementations are always expected to pass (they provide fallbacks)
        if (test.testingComponent === 'kem' && test.kem.isNoble) return false
        if (test.testingComponent === 'kdf' && test.kdf.isNoble) return false
        if (test.testingComponent === 'aead' && test.aead.isNoble) return false

        // Check if the component being tested is unsupported in current browser
        const componentName = test[test.testingComponent].name
        return unsupported[test.testingComponent].includes(componentName)
      }

      // ============================================================================
      // STATE MANAGEMENT
      // ============================================================================

      let tests = []
      let currentFilter = 'all'

      // ============================================================================
      // TEST GENERATION
      // ============================================================================

      /**
       * Generates the full test suite Strategy: Test each component individually with baseline
       * values for others This avoids testing every combination (which would be thousands of
       * tests)
       */
      function generateTests() {
        const testList = []

        // Test each KEM with baseline KDF and AEAD
        for (const kem of ALL_KEMS) {
          const test = {
            id: testList.length,
            kem,
            kdf: baselineKDF,
            aead: baselineAEAD,
            testingComponent: 'kem',
            status: 'pending',
            error: null,
          }
          test.expectedToFail = isExpectedToFail(test)
          testList.push(test)
        }

        // Test each KDF with baseline KEM and AEAD
        for (const kdf of ALL_KDFS) {
          const test = {
            id: testList.length,
            kem: baselineKEM,
            kdf,
            aead: baselineAEAD,
            testingComponent: 'kdf',
            status: 'pending',
            error: null,
          }
          test.expectedToFail = isExpectedToFail(test)
          testList.push(test)
        }

        // Test each AEAD with baseline KEM and KDF
        for (const aead of ALL_AEADS) {
          const test = {
            id: testList.length,
            kem: baselineKEM,
            kdf: baselineKDF,
            aead,
            testingComponent: 'aead',
            status: 'pending',
            error: null,
          }
          test.expectedToFail = isExpectedToFail(test)
          testList.push(test)
        }

        return testList
      }

      // ============================================================================
      // UI RENDERING FUNCTIONS
      // ============================================================================

      /** Gets the component object from a test based on the test's component type */
      function getTestComponent(test) {
        return test.testingComponent === 'kem'
          ? test.kem
          : test.testingComponent === 'kdf'
            ? test.kdf
            : test.aead
      }

      /** Determines the display status for an algorithm card */
      function getAlgorithmStatus(algoName, algoType) {
        // Find ALL tests for this algorithm (native and extensibility)
        const relatedTests = tests.filter((t) => {
          const component = getTestComponent(t)
          return component.name === algoName && t.testingComponent === algoType
        })

        if (relatedTests.length === 0) {
          return 'pending'
        }

        // Check if any test is running
        if (relatedTests.some((t) => t.status === 'running')) {
          return 'testing'
        }

        // Check if any test is still pending
        if (relatedTests.some((t) => t.status === 'pending')) {
          return 'pending'
        }

        // Priority: native passed > noble passed > unsupported
        const nativeTest = relatedTests.find((t) => !getTestComponent(t).isNoble)
        const nobleTest = relatedTests.find((t) => getTestComponent(t).isNoble)

        // If native test passed, show as native
        if (nativeTest && nativeTest.status === 'passed') {
          return 'native'
        }

        // If noble test passed, show as noble
        if (nobleTest && nobleTest.status === 'passed') {
          return 'noble'
        }

        // Both failed or no passing tests
        return 'unsupported'
      }

      /**
       * Renders the algorithm summary cards at the top of the page Shows the status of each KEM,
       * KDF, and AEAD algorithm
       */
      function renderAlgorithmSummary() {
        const summaryDiv = document.getElementById('summary')

        // Get unique algorithm names
        const kemNames = [...new Set(ALL_KEMS.map((k) => k.name))].sort()
        const kdfNames = [...new Set(ALL_KDFS.map((k) => k.name))].sort()
        const aeadNames = [...new Set(ALL_AEADS.map((a) => a.name))].sort()

        const sections = [
          { title: 'Key Encapsulation Mechanisms (KEM)', algos: kemNames, type: 'kem' },
          { title: 'Key Derivation Functions (KDF)', algos: kdfNames, type: 'kdf' },
          { title: 'Authenticated Encryption (AEAD)', algos: aeadNames, type: 'aead' },
        ]

        summaryDiv.innerHTML = sections
          .map(
            (section) => `
        <div class="algorithm-section">
          <h3>${section.title}</h3>
          <div class="algorithm-grid">
            ${section.algos
              .map((algoName) => {
                const status = getAlgorithmStatus(algoName, section.type)
                const statusText =
                  status === 'native'
                    ? 'Native'
                    : status === 'noble'
                      ? 'extensibility'
                      : status === 'pending'
                        ? 'Pending'
                        : status === 'testing'
                          ? 'Testing...'
                          : 'Unsupported'
                const displayName = algoName.replace(/^(KEM_|KDF_|AEAD_)/, '')
                const showCheckmark = status === 'native' || status === 'noble'

                return `
                <div class="algo-card ${status}" data-algo="${algoName}" data-type="${section.type}">
                  <div class="algo-name">${displayName}</div>
                  <div class="algo-status">${statusText}</div>
                  ${showCheckmark ? '<div class="checkmark">âœ“</div>' : ''}
                </div>
              `
              })
              .join('')}
          </div>
        </div>
      `,
          )
          .join('')
      }

      /** Updates the filter button counts and visibility Called whenever test statuses change */
      function updateSummary() {
        const total = tests.length
        const running = tests.filter((t) => t.status === 'running').length
        const passed = tests.filter((t) => t.status === 'passed').length
        const failed = tests.filter((t) => t.status === 'failed').length

        // Calculate counts for all filter buttons
        const nativeCount = tests.filter((t) => !getTestComponent(t).isNoble).length
        const nobleCount = tests.filter((t) => getTestComponent(t).isNoble).length

        const expectedFailures = tests.filter(
          (t) => t.status === 'failed' && t.expectedToFail,
        ).length
        const unexpectedPasses = tests.filter(
          (t) => t.status === 'passed' && t.expectedToFail,
        ).length
        const unexpectedFailures = tests.filter(
          (t) => t.status === 'failed' && !t.expectedToFail,
        ).length
        const pending = tests.filter((t) => t.status === 'pending').length

        // Update all filter buttons with counts
        const allBtn = document.querySelector('[data-filter="all"]')
        const nativeBtn = document.querySelector('[data-filter="native"]')
        const nobleBtn = document.querySelector('[data-filter="noble"]')
        const passedBtn = document.querySelector('[data-filter="passed"]')
        const passedUnexpectedBtn = document.querySelector('[data-filter="passed-unexpected"]')
        const failedExpectedBtn = document.querySelector('[data-filter="failed-expected"]')
        const failedUnexpectedBtn = document.querySelector('[data-filter="failed-unexpected"]')
        const pendingBtn = document.querySelector('[data-filter="pending"]')

        if (allBtn) allBtn.textContent = `All (${total})`
        if (nativeBtn) nativeBtn.textContent = `Native (${nativeCount})`
        if (nobleBtn) nobleBtn.textContent = `Extensibility (${nobleCount})`
        if (passedBtn) passedBtn.textContent = `Passed (${passed})`
        if (failedExpectedBtn)
          failedExpectedBtn.textContent = `Failed (Expected) (${expectedFailures})`

        if (passedUnexpectedBtn) {
          if (unexpectedPasses > 0) {
            passedUnexpectedBtn.style.display = ''
            passedUnexpectedBtn.textContent = `Passed (Unexpected) âš ï¸ (${unexpectedPasses})`
          } else {
            passedUnexpectedBtn.style.display = 'none'
          }
        }
        if (failedUnexpectedBtn) {
          if (unexpectedFailures > 0) {
            failedUnexpectedBtn.style.display = ''
            failedUnexpectedBtn.textContent = `Failed (Unexpected) âš ï¸ (${unexpectedFailures})`
          } else {
            failedUnexpectedBtn.style.display = 'none'
          }
        }
        if (pendingBtn) {
          if (pending > 0) {
            pendingBtn.style.display = ''
            pendingBtn.textContent = `Pending (${pending})`
          } else {
            pendingBtn.style.display = 'none'
          }
        }
      }

      /** Gets the display name for a test (shows the component being tested) */
      function getTestDisplayName(test) {
        const component = getTestComponent(test)
        return component.displayName || component.name
      }

      /** Renders a single test item as HTML */
      function renderTest(test) {
        const testName = getTestDisplayName(test)

        // Determine status display
        let statusClass = test.status
        let statusText = test.status
        let showStatus = true

        if (test.expectedToFail && test.status === 'failed') {
          // Expected failure - don't show status pill
          statusClass = 'expected'
          statusText = 'expected'
          showStatus = false
        } else if (test.expectedToFail && test.status === 'passed') {
          // Unexpected pass
          statusClass = 'passed-unexpected'
          statusText = 'unexpected pass'
        }

        return `
        <div class="test-item ${statusClass}" data-id="${test.id}" data-status="${test.status}">
          <div class="test-header">
            <div class="test-name">${testName}</div>
            ${
              showStatus
                ? `<div class="test-status ${statusClass}">
              ${test.status === 'running' ? '<span class="loader"></span>' : ''}
              ${statusText}
            </div>`
                : ''
            }
          </div>
          ${test.error ? `<div class="test-error">${escapeHtml(test.error)}</div>` : ''}
        </div>
      `
      }

      /** Escapes HTML characters in text to prevent XSS */
      function escapeHtml(text) {
        const div = document.createElement('div')
        div.textContent = text
        return div.innerHTML
      }

      /** Filters tests based on the current filter setting */
      function getFilteredTests() {
        if (currentFilter === 'all') {
          return tests
        } else if (currentFilter === 'native') {
          return tests.filter((t) => !getTestComponent(t).isNoble)
        } else if (currentFilter === 'noble') {
          return tests.filter((t) => getTestComponent(t).isNoble)
        } else if (currentFilter === 'failed-expected') {
          return tests.filter((t) => t.status === 'failed' && t.expectedToFail)
        } else if (currentFilter === 'failed-unexpected') {
          return tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
        } else if (currentFilter === 'passed-unexpected') {
          return tests.filter((t) => t.status === 'passed' && t.expectedToFail)
        } else {
          return tests.filter((t) => t.status === currentFilter)
        }
      }

      /** Renders the test grid with filtered tests */
      function renderTests() {
        const grid = document.getElementById('testGrid')
        const filteredTests = getFilteredTests()
        grid.innerHTML = filteredTests.map(renderTest).join('')
      }

      // ============================================================================
      // TEST EXECUTION
      // ============================================================================

      /** Performs encryption/decryption test for regular AEAD modes */
      async function testRegularAEAD(suite, recipientKeyPair) {
        const plaintext = new TextEncoder().encode('Hello, HPKE!')
        const aad = new TextEncoder().encode('additional data')

        // Sender seals using recipient's public key
        const { encapsulatedKey, ciphertext } = await suite.Seal(
          recipientKeyPair.publicKey,
          plaintext,
          aad,
        )

        // Recipient opens using their private key
        const decrypted = await suite.Open(recipientKeyPair, encapsulatedKey, ciphertext, aad)

        // Verify decrypted matches plaintext
        const decryptedText = new TextDecoder().decode(decrypted)
        if (decryptedText !== 'Hello, HPKE!') {
          throw new Error(`Decryption mismatch: expected "Hello, HPKE!", got "${decryptedText}"`)
        }
      }

      /** Performs export-only mode test */
      async function testExportOnlyMode(suite, recipientKeyPair) {
        const exporterContext = new TextEncoder().encode('test context')
        const L = 32

        // Sender exports secret using recipient's public key
        const { encapsulatedKey, exportedSecret } = await suite.SendExport(
          recipientKeyPair.publicKey,
          exporterContext,
          L,
        )

        // Recipient receives exported secret using their private key
        const receivedSecret = await suite.ReceiveExport(
          recipientKeyPair,
          encapsulatedKey,
          exporterContext,
          L,
        )

        // Verify the secrets match
        assertUint8ArraysEqual(exportedSecret, receivedSecret, 'Exported secret mismatch')
      }

      /** Helper to find a matching implementation, preferring native over Noble */
      function findMatchingImplementation(algorithms, algorithmId, unsupportedList) {
        // Prefer native implementations that are supported
        return (
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return !a.isNoble && !unsupportedList.includes(a.name)
          }) ||
          // Fall back to Noble implementation
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return a.isNoble
          })
        )
      }

      /** Helper to verify two Uint8Arrays match */
      function assertUint8ArraysEqual(actual, expected, errorPrefix) {
        if (actual.length !== expected.length) {
          throw new Error(`${errorPrefix}: length mismatch`)
        }
        for (let i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) {
            throw new Error(`${errorPrefix}: content mismatch`)
          }
        }
      }

      /** Runs a single test for a KEM/KDF/AEAD combination */
      async function runTest(test) {
        test.status = 'running'
        renderTests()
        updateSummary()
        renderAlgorithmSummary()

        try {
          // Check if a test vector exists where we have implementations of all components
          let hasVector = false
          let vectorToUse = null

          if (test.testingComponent === 'kem') {
            const kemId = ALGORITHM_IDS[test.kem.name]

            // Find a vector with this KEM where we have expected-to-pass implementations for the KDF and AEAD
            vectorToUse = allVectors.find((v) => {
              if (v.kem_id !== kemId) return false

              const kdfMatch = findMatchingImplementation(ALL_KDFS, v.kdf_id, unsupported.kdf)
              const aeadMatch = findMatchingImplementation(ALL_AEADS, v.aead_id, unsupported.aead)

              return kdfMatch && aeadMatch
            })
            hasVector = !!vectorToUse
          } else if (test.testingComponent === 'kdf') {
            const kdfId = ALGORITHM_IDS[test.kdf.name]

            // Find a vector with this KDF where we have expected-to-pass implementations for the KEM and AEAD
            vectorToUse = allVectors.find((v) => {
              if (v.kdf_id !== kdfId) return false

              const kemMatch = findMatchingImplementation(ALL_KEMS, v.kem_id, unsupported.kem)
              const aeadMatch = findMatchingImplementation(ALL_AEADS, v.aead_id, unsupported.aead)

              return kemMatch && aeadMatch
            })
            hasVector = !!vectorToUse
          } else if (test.testingComponent === 'aead') {
            const aeadId = ALGORITHM_IDS[test.aead.name]

            // Find a vector with this AEAD where we have expected-to-pass implementations for the KEM and KDF
            vectorToUse = allVectors.find((v) => {
              if (v.aead_id !== aeadId) return false

              const kemMatch = findMatchingImplementation(ALL_KEMS, v.kem_id, unsupported.kem)
              const kdfMatch = findMatchingImplementation(ALL_KDFS, v.kdf_id, unsupported.kdf)

              return kemMatch && kdfMatch
            })
            hasVector = !!vectorToUse
          }

          test.hasVector = hasVector

          // Pass 1: Test with baseline components (existing behavior)
          const suite = new HPKE.CipherSuite(test.kem.factory, test.kdf.factory, test.aead.factory)

          // Generate test key pair
          await suite.GenerateKeyPair()
          const ikm = crypto.getRandomValues(new Uint8Array(suite.KEM.Nsk))
          const keyPair = await suite.DeriveKeyPair(ikm, true)

          // Serialize and deserialize keys to test that functionality
          const serializedPublicKey = await suite.SerializePublicKey(keyPair.publicKey)
          const serializedPrivateKey = await suite.SerializePrivateKey(keyPair.privateKey)
          const recipientPrivateKey = await suite.DeserializePrivateKey(serializedPrivateKey, true)
          const recipientPublicKey = await suite.DeserializePublicKey(serializedPublicKey)
          const recipientKeyPair = {
            publicKey: recipientPublicKey,
            privateKey: recipientPrivateKey,
          }

          // Test based on AEAD mode
          if (test.aead.name === 'AEAD_EXPORT_ONLY') {
            await testExportOnlyMode(suite, recipientKeyPair)
          } else {
            await testRegularAEAD(suite, recipientKeyPair)
          }

          // Pass 2: If we have a vector, test against it
          if (hasVector && vectorToUse) {
            // Find the matching components from the vector - prefer native, fallback to Noble
            const vectorKemMatch = findMatchingImplementation(
              ALL_KEMS,
              vectorToUse.kem_id,
              unsupported.kem,
            )
            const vectorKdfMatch = findMatchingImplementation(
              ALL_KDFS,
              vectorToUse.kdf_id,
              unsupported.kdf,
            )
            const vectorAeadMatch = findMatchingImplementation(
              ALL_AEADS,
              vectorToUse.aead_id,
              unsupported.aead,
            )

            if (vectorKemMatch && vectorKdfMatch && vectorAeadMatch) {
              // Create suite with vector's components
              const vectorSuite = new HPKE.CipherSuite(
                vectorKemMatch.factory,
                vectorKdfMatch.factory,
                vectorAeadMatch.factory,
              )

              // Derive recipient key pair from vector's ikmR
              const ikmR = Uint8Array.fromHex(vectorToUse.ikmR)
              const vectorRecipientKeyPair = await vectorSuite.DeriveKeyPair(ikmR, true)

              // Verify serialized keys match the vector's skRm and pkRm
              const serializedPrivateKey = await vectorSuite.SerializePrivateKey(
                vectorRecipientKeyPair.privateKey,
              )
              const expectedPrivateKey = Uint8Array.fromHex(vectorToUse.skRm)
              assertUint8ArraysEqual(
                serializedPrivateKey,
                expectedPrivateKey,
                'Vector test: Private key mismatch',
              )

              const serializedPublicKey = await vectorSuite.SerializePublicKey(
                vectorRecipientKeyPair.publicKey,
              )
              const expectedPublicKey = Uint8Array.fromHex(vectorToUse.pkRm)
              assertUint8ArraysEqual(
                serializedPublicKey,
                expectedPublicKey,
                'Vector test: Public key mismatch',
              )

              // Test against first encryption in the vector
              if (vectorToUse.encryptions && vectorToUse.encryptions.length > 0) {
                const firstEnc = vectorToUse.encryptions[0]
                const enc = Uint8Array.fromHex(vectorToUse.enc)
                const ciphertext = Uint8Array.fromHex(firstEnc.ct)
                const aad = Uint8Array.fromHex(firstEnc.aad)
                const expectedPlaintext = Uint8Array.fromHex(firstEnc.pt)

                // Build options object based on mode
                const options = {
                  info: Uint8Array.fromHex(vectorToUse.info),
                  psk: vectorToUse.psk ? Uint8Array.fromHex(vectorToUse.psk) : undefined,
                  pskId: vectorToUse.psk_id ? Uint8Array.fromHex(vectorToUse.psk_id) : undefined,
                }

                // Use one-shot Open API
                const decrypted = await vectorSuite.Open(
                  vectorRecipientKeyPair,
                  enc,
                  ciphertext,
                  aad,
                  options,
                )

                // Verify the decrypted plaintext matches
                assertUint8ArraysEqual(
                  decrypted,
                  expectedPlaintext,
                  'Vector test: Decrypted mismatch',
                )
              }
            }
          }

          test.status = 'passed'
          test.error = null
        } catch (error) {
          test.status = 'failed'
          test.error = error.message || String(error)

          // Log unexpected failures to console
          if (!test.expectedToFail) {
            console.error(`Unexpected failure: ${getTestDisplayName(test)}`, error)
          }
        }

        renderTests()
        updateSummary()
        renderAlgorithmSummary()
      }

      /** Runs all tests in randomized order */
      async function runAllTests() {
        // Randomize test order for variety
        const randomizedTests = [...tests].sort(() => Math.random() - 0.5)

        for (const test of randomizedTests) {
          await runTest(test)
          // Small delay to allow UI updates
          await new Promise((resolve) => setTimeout(resolve, 10))
        }

        // Expose results to globalThis after all tests complete
        updateGlobalResults()
      }

      // ============================================================================
      // RESULTS EXPORT
      // ============================================================================

      /** Exposes test results on globalThis for external access */
      function updateGlobalResults() {
        globalThis.hpkeTestResults = {
          total: tests.length,
          passed: tests.filter((t) => t.status === 'passed').length,
          failed: tests.filter((t) => t.status === 'failed').length,
          expectedFailures: tests.filter((t) => t.status === 'failed' && t.expectedToFail).length,
          unexpectedFailures: tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
            .length,
          unexpectedPasses: tests.filter((t) => t.status === 'passed' && t.expectedToFail).length,
          tests: tests.map((t) => ({
            id: t.id,
            component: t.testingComponent,
            name:
              t.testingComponent === 'kem'
                ? t.kem.displayName || t.kem.name
                : t.testingComponent === 'kdf'
                  ? t.kdf.displayName || t.kdf.name
                  : t.aead.displayName || t.aead.name,
            suite: {
              kem: t.kem.displayName || t.kem.name,
              kdf: t.kdf.displayName || t.kdf.name,
              aead: t.aead.displayName || t.aead.name,
            },
            status: t.status,
            expectedToFail: t.expectedToFail,
            error: t.error,
          })),
        }
      }

      // ============================================================================
      // FILTER MANAGEMENT
      // ============================================================================

      /** Sets up filter buttons and loads saved filter preference */
      function setupFilters() {
        // Load saved filter from localStorage
        const savedFilter = localStorage.getItem('hpkeTestFilter')
        if (savedFilter) {
          currentFilter = savedFilter
          // Update active button
          document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
          const activeBtn = document.querySelector(`[data-filter="${savedFilter}"]`)
          if (activeBtn) {
            activeBtn.classList.add('active')
          }
        }

        // Add click handlers to filter buttons
        document.querySelectorAll('.filter-btn').forEach((btn) => {
          btn.addEventListener('click', (e) => {
            document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
            e.target.classList.add('active')
            currentFilter = e.target.dataset.filter
            // Save filter preference to localStorage
            localStorage.setItem('hpkeTestFilter', currentFilter)
            renderTests()
          })
        })
      }

      // ============================================================================
      // INITIALIZATION
      // ============================================================================

      /** Initializes the test suite and starts execution */
      async function init() {
        tests = generateTests()
        renderAlgorithmSummary()
        setupFilters()
        updateSummary()
        renderTests()
        await runAllTests()
      }

      init()
    </script>
  </body>
</html>
