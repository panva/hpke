<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@panva/hpke Browser Test Suite</title>
    <script type="importmap">
      {
        "imports": {
          "@panva/hpke": "./index.js",
          "@panva/hpke-noble": "./examples/noble-suite/index.js",
          "@noble/": "./node_modules/@noble/",
          "./examples/noble-suite/kem.ts": "./examples/noble-suite/kem.js",
          "./examples/noble-suite/aead.ts": "./examples/noble-suite/aead.js",
          "./examples/noble-suite/kdf.ts": "./examples/noble-suite/kdf.js",
          "./index.ts": "./index.js",
          "bowser": "https://cdn.jsdelivr.net/npm/bowser@2/+esm"
        }
      }
    </script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          sans-serif;
        padding: 20px;
        background: rgb(13, 17, 23);
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgb(22, 27, 34);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        padding: 30px;
      }

      h1 {
        color: #e6edf3;
        margin-bottom: 10px;
        font-size: 32px;
      }

      h1 a {
        color: #8b949e;
        text-decoration: none;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .subtitle {
        color: #8b949e;
        margin-bottom: 30px;
        font-size: 16px;
      }

      .summary {
        margin-bottom: 30px;
      }

      .legend {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        padding: 12px;
        background: rgba(110, 118, 129, 0.1);
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #8b949e;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border: 2px solid;
      }

      .legend-color.native {
        background: rgba(46, 160, 67, 0.15);
        border-color: #3fb950;
      }

      .legend-color.noble {
        background: rgba(56, 139, 253, 0.15);
        border-color: #388bfd;
      }

      .legend-color.both {
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-color: #3fb950;
        border-image: linear-gradient(135deg, #3fb950 0%, #3fb950 50%, #388bfd 50%, #388bfd 100%) 1;
      }

      .legend-color.unsupported {
        background: rgba(248, 81, 73, 0.15);
        border-color: #f85149;
      }

      .algorithm-section {
        margin-bottom: 25px;
      }

      .algorithm-section h3 {
        font-size: 18px;
        color: #e6edf3;
        margin-bottom: 12px;
        font-weight: 600;
      }

      .algorithm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
      }

      .algo-card {
        padding: 12px;
        border: 2px solid;
        font-size: 13px;
        font-family: 'Monaco', 'Courier New', monospace;
        transition: all 0.2s ease;
      }

      .algo-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .algo-card.native {
        background: rgba(46, 160, 67, 0.15);
        border-color: #3fb950;
        color: #e6edf3;
      }

      .algo-card.noble {
        background: rgba(56, 139, 253, 0.15);
        border-color: #388bfd;
        color: #e6edf3;
      }

      .algo-card.both {
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-color: #3fb950;
        border-width: 2px;
        border-style: solid;
        border-image: linear-gradient(135deg, #3fb950 0%, #3fb950 50%, #388bfd 50%, #388bfd 100%) 1;
        color: #e6edf3;
      }

      .algo-card.unsupported {
        background: rgba(248, 81, 73, 0.15);
        border-color: #f85149;
        color: #e6edf3;
      }

      .algo-card.pending {
        background: rgba(110, 118, 129, 0.1);
        border-color: #30363d;
        color: #e6edf3;
      }

      .algo-card.testing {
        background: rgba(187, 128, 9, 0.15);
        border-color: #bb8009;
        color: #e6edf3;
      }

      .algo-card {
        position: relative;
      }

      .algo-card .algo-name {
        font-weight: 600;
        margin-bottom: 4px;
        word-break: break-word;
      }

      .test-grid {
        display: grid;
        gap: 15px;
      }

      .test-item {
        border: 2px solid #30363d;
        padding: 15px;
        transition: all 0.3s ease;
        background: rgb(13, 17, 23);
      }

      .test-item.running {
        border-color: #bb8009;
        background: rgba(187, 128, 9, 0.1);
        animation: pulse 1.5s ease-in-out infinite;
      }

      .test-item.passed {
        border-color: #3fb950;
        background: rgba(46, 160, 67, 0.1);
      }

      .test-item.failed {
        border-color: #f85149;
        background: rgba(248, 81, 73, 0.1);
      }

      .test-item.expected {
        border-color: #6e7681;
        background: rgba(110, 118, 129, 0.1);
      }

      .test-item.passed-unexpected {
        border-color: #58a6ff;
        background: rgba(56, 139, 253, 0.1);
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
      }

      .test-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .test-name {
        font-weight: 600;
        font-size: 16px;
        color: #e6edf3;
        font-family: 'Monaco', 'Courier New', monospace;
        word-break: break-word;
        overflow-wrap: break-word;
        flex: 1;
        min-width: 0;
      }

      .test-status {
        padding: 4px 12px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .test-status.pending {
        background: #e0e0e0;
        color: #666;
      }

      .test-status.running {
        background: #ffc107;
        color: #000;
      }

      .test-status.passed {
        background: #28a745;
        color: white;
      }

      .test-status.failed {
        background: #dc3545;
        color: white;
      }

      .test-status.expected {
        background: #6c757d;
        color: white;
      }

      .test-status.passed-unexpected {
        background: #17a2b8;
        color: white;
      }

      .test-details {
        font-size: 13px;
        color: #8b949e;
        margin-bottom: 8px;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .test-error {
        margin-top: 10px;
        padding: 10px;
        background: rgba(248, 81, 73, 0.15);
        border-left: 4px solid #f85149;

        font-size: 13px;
        color: #ff7b72;
        font-family: 'Monaco', 'Courier New', monospace;
        overflow-x: auto;
      }

      .test-duration {
        font-size: 12px;
        color: #6e7681;
        margin-top: 5px;
      }

      .expected-failure {
        display: inline-block;
        margin-left: 8px;
        padding: 2px 8px;
        background: #6c757d;
        color: white;

        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .loader {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #ffc107;

        animation: spin 1s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .filter-buttons {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .filter-btn {
        padding: 8px 16px;
        border: 2px solid #30363d;
        background: rgb(13, 17, 23);
        color: #e6edf3;

        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s ease;
      }

      .filter-btn:hover {
        background: #30363d;
        border-color: #6e7681;
      }

      .filter-btn.active {
        background: #388bfd;
        color: white;
        border-color: #388bfd;
      }

      .hidden {
        display: none;
      }

      .vector-validation {
        margin-bottom: 30px;
        padding: 20px;
        background: rgb(13, 17, 23);

        border: 2px solid #30363d;
      }

      .vector-validation.running {
        border-color: #bb8009;
      }

      .vector-validation.passed {
        border-color: #3fb950;
      }

      .vector-validation.failed {
        border-color: #f85149;
      }

      .vector-validation h3 {
        font-size: 18px;
        color: #e6edf3;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .vector-validation .subtitle-text {
        font-size: 13px;
        color: #8b949e;
        margin-bottom: 15px;
      }

      .progress-bar-container {
        background: rgb(22, 27, 34);

        height: 24px;
        overflow: hidden;
        margin-bottom: 10px;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3fb950, #7ee787);
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 8px;
      }

      .progress-bar.failed {
        background: linear-gradient(90deg, #f85149, #ff7b72);
      }

      .progress-text {
        font-size: 12px;
        font-weight: 600;
        color: white;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }

      .progress-info {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: #8b949e;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .progress-info .passed {
        color: #7ee787;
      }

      .progress-info .failed {
        color: #ff7b72;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>
        @panva/hpke Browser Test Suite
        <a href="https://github.com/panva/hpke" target="_blank">ðŸ”—</a>
      </h1>
      <p class="subtitle">Testing all KEM, KDF, and AEAD implementations in your browser</p>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-color native"></div>
          <span>Native (Web Cryptography)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color noble"></div>
          <span>Extensibility (Noble Cryptography)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color both"></div>
          <span>Both implementations</span>
        </div>
        <div class="legend-item">
          <div class="legend-color unsupported"></div>
          <span>Unsupported</span>
        </div>
      </div>

      <div class="summary" id="summary"></div>

      <div class="vector-validation" id="vectorValidation">
        <h3>Test Vector Validation</h3>
        <p class="subtitle-text">
          Testing all encryptions and exports from RFC test vectors with functional implementations
        </p>
        <div class="progress-bar-container">
          <div class="progress-bar" id="vectorProgress" style="width: 0%">
            <span class="progress-text" id="vectorProgressText">0%</span>
          </div>
        </div>
        <div class="progress-info" id="vectorProgressInfo">
          <span>Pending...</span>
        </div>
      </div>

      <div class="filter-buttons hidden">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="native">Native</button>
        <button class="filter-btn" data-filter="noble">extensibility</button>
        <button class="filter-btn" data-filter="passed">Passed</button>
        <button class="filter-btn" data-filter="passed-unexpected">Passed (Unexpected)</button>
        <button class="filter-btn" data-filter="failed-expected">Failed (Expected)</button>
        <button class="filter-btn" data-filter="failed-unexpected">Failed (Unexpected)</button>
        <button class="filter-btn" data-filter="pending">Pending</button>
      </div>

      <div class="test-grid hidden" id="testGrid"></div>
    </div>

    <script type="module">
      import * as HPKE from '@panva/hpke'
      import * as Noble from '@panva/hpke-noble'
      import Bowser from 'bowser'

      import vectors from './test/vectors.json' with { type: 'json' }
      import vectorsPq from './test/vectors-pq.json' with { type: 'json' }
      const allVectors = [...vectors, ...vectorsPq].filter((v) => {
        if (v.mode !== 0x00 && v.mode !== 0x01) return false
        return true
      })

      // ============================================================================
      // ALGORITHM DISCOVERY
      // ============================================================================
      // Dynamically extract all algorithms from HPKE and Noble libraries based on
      // name prefixes (KEM_, KDF_, AEAD_)

      /** Extracts algorithms from a library object by prefix */
      function extractAlgorithms(library, prefix, label, isNoble = false) {
        return Object.keys(library)
          .filter((key) => key.startsWith(prefix))
          .map((name) => ({
            name,
            displayName: `[${label}] ${name}`,
            factory: library[name],
            isNoble,
          }))
          .sort((a, b) => a.name.localeCompare(b.name))
      }

      // Extract native HPKE algorithms
      const KEMS = extractAlgorithms(HPKE, 'KEM_', 'native')
      const KDFS = extractAlgorithms(HPKE, 'KDF_', 'native')
      const AEADS = extractAlgorithms(HPKE, 'AEAD_', 'native')

      // Extract Noble (extensibility) algorithms
      const NOBLE_KEMS = extractAlgorithms(Noble, 'KEM_', 'extensibility', true)
      const NOBLE_KDFS = extractAlgorithms(Noble, 'KDF_', 'extensibility', true)
      const NOBLE_AEADS = extractAlgorithms(Noble, 'AEAD_', 'extensibility', true)

      // Combine native and Noble implementations
      const ALL_KEMS = [...KEMS, ...NOBLE_KEMS]
      const ALL_KDFS = [...KDFS, ...NOBLE_KDFS]
      const ALL_AEADS = [...AEADS, ...NOBLE_AEADS]

      // ============================================================================
      // ALGORITHM ID MAPPINGS
      // ============================================================================
      // Static mapping of algorithm names to their IDs from the HPKE specification

      const ALGORITHM_IDS = {
        // KEMs
        KEM_DHKEM_P256_HKDF_SHA256: 0x0010,
        KEM_DHKEM_P384_HKDF_SHA384: 0x0011,
        KEM_DHKEM_P521_HKDF_SHA512: 0x0012,
        KEM_DHKEM_X25519_HKDF_SHA256: 0x0020,
        KEM_DHKEM_X448_HKDF_SHA512: 0x0021,
        KEM_ML_KEM_512: 0x0040,
        KEM_ML_KEM_768: 0x0041,
        KEM_ML_KEM_1024: 0x0042,
        KEM_MLKEM768_P256: 0x0050,
        KEM_MLKEM1024_P384: 0x0051,
        KEM_MLKEM768_X25519: 0x647a,

        // KDFs
        KDF_HKDF_SHA256: 0x0001,
        KDF_HKDF_SHA384: 0x0002,
        KDF_HKDF_SHA512: 0x0003,
        KDF_SHAKE128: 0x0010,
        KDF_SHAKE256: 0x0011,
        KDF_TurboSHAKE128: 0x0012,
        KDF_TurboSHAKE256: 0x0013,

        // AEADs
        AEAD_AES_128_GCM: 0x0001,
        AEAD_AES_256_GCM: 0x0002,
        AEAD_ChaCha20Poly1305: 0x0003,
        AEAD_EXPORT_ONLY: 0xffff,
      }

      // Mapping of algorithm names to their display names
      const ALGORITHM_NAMES = {
        // KEMs
        KEM_DHKEM_P256_HKDF_SHA256: 'DHKEM(P-256, HKDF-SHA256)',
        KEM_DHKEM_P384_HKDF_SHA384: 'DHKEM(P-384, HKDF-SHA384)',
        KEM_DHKEM_P521_HKDF_SHA512: 'DHKEM(P-521, HKDF-SHA512)',
        KEM_DHKEM_X25519_HKDF_SHA256: 'DHKEM(X25519, HKDF-SHA256)',
        KEM_DHKEM_X448_HKDF_SHA512: 'DHKEM(X448, HKDF-SHA512)',
        KEM_ML_KEM_512: 'ML-KEM-512',
        KEM_ML_KEM_768: 'ML-KEM-768',
        KEM_ML_KEM_1024: 'ML-KEM-1024',
        KEM_MLKEM768_P256: 'MLKEM768-P256',
        KEM_MLKEM1024_P384: 'MLKEM1024-P384',
        KEM_MLKEM768_X25519: 'MLKEM768-X25519',

        // KDFs
        KDF_HKDF_SHA256: 'HKDF-SHA256',
        KDF_HKDF_SHA384: 'HKDF-SHA384',
        KDF_HKDF_SHA512: 'HKDF-SHA512',
        KDF_SHAKE128: 'SHAKE128',
        KDF_SHAKE256: 'SHAKE256',
        KDF_TurboSHAKE128: 'TurboSHAKE128',
        KDF_TurboSHAKE256: 'TurboSHAKE256',

        // AEADs
        AEAD_AES_128_GCM: 'AES-128-GCM',
        AEAD_AES_256_GCM: 'AES-256-GCM',
        AEAD_ChaCha20Poly1305: 'ChaCha20Poly1305',
        AEAD_EXPORT_ONLY: 'Export-only',
      }

      // Validate that all algorithms have IDs and names in the maps
      const allAlgorithms = [
        ...KEMS,
        ...KDFS,
        ...AEADS,
        ...NOBLE_KEMS,
        ...NOBLE_KDFS,
        ...NOBLE_AEADS,
      ]
      const missingIds = []
      const missingNames = []

      for (const algo of allAlgorithms) {
        if (!(algo.name in ALGORITHM_IDS)) {
          missingIds.push(algo.name)
        }
        if (!(algo.name in ALGORITHM_NAMES)) {
          missingNames.push(algo.name)
        }
      }

      if (missingIds.length > 0 || missingNames.length > 0) {
        const errors = []
        if (missingIds.length > 0) {
          errors.push(`Missing ALGORITHM_IDS entries: ${missingIds.join(', ')}`)
        }
        if (missingNames.length > 0) {
          errors.push(`Missing ALGORITHM_NAMES entries: ${missingNames.join(', ')}`)
        }
        throw new Error(`Configuration Error:\n${errors.join('\n')}`)
      }

      // ============================================================================
      // BASELINE CONFIGURATION
      // ============================================================================
      // When testing a specific component (e.g., a KEM), we pair it with baseline
      // KDF and AEAD to isolate the test. These are the baseline algorithms.

      const baselineKEM = KEMS.find((k) => k.name === 'KEM_DHKEM_P256_HKDF_SHA256')
      const baselineKDF = KDFS.find((k) => k.name === 'KDF_HKDF_SHA256')
      const baselineAEAD = AEADS.find((a) => a.name === 'AEAD_AES_128_GCM')

      // ============================================================================
      // BROWSER COMPATIBILITY
      // ============================================================================
      // Some algorithms are not supported in browsers due to missing Web Crypto APIs
      // Noble implementations provide fallbacks for these
      // Browser-specific unsupported algorithms based on Web Crypto API availability

      /** Detects the current browser engine and version */
      function detectBrowser() {
        const browser = Bowser.getParser(navigator.userAgent)
        return {
          engine: browser.getEngineName(),
          version: parseInt(browser.getBrowserVersion()),
        }
      }

      const unsupported = {
        kem: [
          'KEM_DHKEM_X448_HKDF_SHA512',
          'KEM_ML_KEM_512',
          'KEM_ML_KEM_768',
          'KEM_ML_KEM_1024',
          'KEM_MLKEM768_X25519',
          'KEM_MLKEM768_P256',
          'KEM_MLKEM1024_P384',
        ],
        kdf: ['KDF_SHAKE128', 'KDF_SHAKE256'],
        aead: ['AEAD_ChaCha20Poly1305'],
      }

      const browser = detectBrowser()

      switch (true) {
        case browser.engine === 'Gecko' && browser.version < 143:
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1932396
          unsupported.kem.push('KEM_DHKEM_X25519_HKDF_SHA256')
          break
      }

      /**
       * Determines if a test is expected to fail based on browser support Noble implementations are
       * always expected to work (they provide fallbacks)
       */
      function isExpectedToFail(test) {
        // Noble implementations are always expected to pass (they provide fallbacks)
        if (test.testingComponent === 'kem' && test.kem.isNoble) return false
        if (test.testingComponent === 'kdf' && test.kdf.isNoble) return false
        if (test.testingComponent === 'aead' && test.aead.isNoble) return false

        // Check if the component being tested is unsupported in current browser
        const componentName = test[test.testingComponent].name
        return unsupported[test.testingComponent].includes(componentName)
      }

      // ============================================================================
      // STATE MANAGEMENT
      // ============================================================================

      let tests = []
      let currentFilter = 'all'

      // Track passing implementations by algorithm ID
      const passingImplementations = {
        kem: new Map(), // id -> [factories]
        kdf: new Map(), // id -> [factories]
        aead: new Map(), // id -> [factories]
      }

      // ============================================================================
      // TEST GENERATION
      // ============================================================================

      /**
       * Generates the full test suite Strategy: Test each component individually with baseline
       * values for others This avoids testing every combination (which would be thousands of
       * tests)
       */
      function generateTests() {
        const testList = []

        const testConfigs = [
          {
            algorithms: ALL_KEMS,
            component: 'kem',
            baselines: { kdf: baselineKDF, aead: baselineAEAD },
          },
          {
            algorithms: ALL_KDFS,
            component: 'kdf',
            baselines: { kem: baselineKEM, aead: baselineAEAD },
          },
          {
            algorithms: ALL_AEADS,
            component: 'aead',
            baselines: { kem: baselineKEM, kdf: baselineKDF },
          },
        ]

        for (const { algorithms, component, baselines } of testConfigs) {
          for (const algorithm of algorithms) {
            const test = {
              id: testList.length,
              ...baselines,
              [component]: algorithm,
              testingComponent: component,
              status: 'pending',
              error: null,
            }
            test.expectedToFail = isExpectedToFail(test)
            testList.push(test)
          }
        }

        return testList
      }

      // ============================================================================
      // UI RENDERING FUNCTIONS
      // ============================================================================

      /** Gets the component object from a test based on the test's component type */
      function getTestComponent(test) {
        return test.testingComponent === 'kem'
          ? test.kem
          : test.testingComponent === 'kdf'
            ? test.kdf
            : test.aead
      }

      /** Determines the display status for an algorithm card */
      function getAlgorithmStatus(algoName, algoType) {
        // Find ALL tests for this algorithm (native and extensibility)
        const relatedTests = tests.filter((t) => {
          const component = getTestComponent(t)
          return component.name === algoName && t.testingComponent === algoType
        })

        if (relatedTests.length === 0) {
          return 'pending'
        }

        // Check if any test is running
        if (relatedTests.some((t) => t.status === 'running')) {
          return 'testing'
        }

        // Check if any test is still pending
        if (relatedTests.some((t) => t.status === 'pending')) {
          return 'pending'
        }

        // Priority: native passed > noble passed > unsupported
        const nativeTest = relatedTests.find((t) => !getTestComponent(t).isNoble)
        const nobleTest = relatedTests.find((t) => getTestComponent(t).isNoble)

        const nativePassed = nativeTest && nativeTest.status === 'passed'
        const noblePassed = nobleTest && nobleTest.status === 'passed'

        // If both native and noble tests passed, show as both
        if (nativePassed && noblePassed) {
          return 'both'
        }

        // If native test passed, show as native
        if (nativePassed) {
          return 'native'
        }

        // If noble test passed, show as noble
        if (noblePassed) {
          return 'noble'
        }

        // Both failed or no passing tests
        return 'unsupported'
      }

      /**
       * Renders the algorithm summary cards at the top of the page Shows the status of each KEM,
       * KDF, and AEAD algorithm
       */
      function renderAlgorithmSummary() {
        const summaryDiv = document.getElementById('summary')

        // Get unique algorithm names
        const kemNames = [...new Set(ALL_KEMS.map((k) => k.name))].sort()
        const kdfNames = [...new Set(ALL_KDFS.map((k) => k.name))].sort()
        const aeadNames = [...new Set(ALL_AEADS.map((a) => a.name))].sort()

        // Categorize KEMs
        const traditionalKEMs = kemNames
          .filter((name) => name.startsWith('KEM_DHKEM_'))
          .sort((a, b) => {
            // Custom sort: P-256, X25519, P-384, P-521, X448
            const order = [
              'KEM_DHKEM_P256_HKDF_SHA256',
              'KEM_DHKEM_X25519_HKDF_SHA256',
              'KEM_DHKEM_P384_HKDF_SHA384',
              'KEM_DHKEM_P521_HKDF_SHA512',
              'KEM_DHKEM_X448_HKDF_SHA512',
            ]
            return order.indexOf(a) - order.indexOf(b)
          })
        const postQuantumKEMs = kemNames
          .filter((name) => name.startsWith('KEM_ML_KEM_'))
          .sort((a, b) => {
            // Sort ML-KEM by security level: 512, 768, 1024
            const getLevel = (name) => parseInt(name.match(/\d+$/)?.[0] || '0')
            return getLevel(a) - getLevel(b)
          })
        const hybridKEMs = kemNames
          .filter((name) => name.startsWith('KEM_MLKEM'))
          .sort((a, b) => {
            // Custom sort: MLKEM768-P256, MLKEM768-X25519, MLKEM1024-P384
            const order = ['KEM_MLKEM768_P256', 'KEM_MLKEM768_X25519', 'KEM_MLKEM1024_P384']
            return order.indexOf(a) - order.indexOf(b)
          })

        const sections = [
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Traditional (T)',
            algos: traditionalKEMs,
            type: 'kem',
          },
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Hybrid (PQ/T)',
            algos: hybridKEMs,
            type: 'kem',
          },
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Post-Quantum (PQ)',
            algos: postQuantumKEMs,
            type: 'kem',
          },
          { title: 'Key Derivation Functions (KDF)', algos: kdfNames, type: 'kdf' },
          { title: 'Authenticated Encryption (AEAD)', algos: aeadNames, type: 'aead' },
        ]

        summaryDiv.innerHTML = sections
          .map(
            (section) => `
        <div class="algorithm-section">
          <h3>${section.title}</h3>
          <div class="algorithm-grid">
            ${section.algos
              .map((algoName) => {
                const status = getAlgorithmStatus(algoName, section.type)
                const displayName = ALGORITHM_NAMES[algoName]

                return (
                  '<div class="algo-card ' +
                  status +
                  '" data-algo="' +
                  algoName +
                  '" data-type="' +
                  section.type +
                  '">' +
                  '<div class="algo-name">' +
                  displayName +
                  '</div>' +
                  '</div>'
                )
              })
              .join('')}
          </div>
        </div>
      `,
          )
          .join('')
      }

      /** Updates the filter button counts and visibility Called whenever test statuses change */
      function updateSummary() {
        const counts = {
          total: tests.length,
          native: tests.filter((t) => !getTestComponent(t).isNoble).length,
          noble: tests.filter((t) => getTestComponent(t).isNoble).length,
          passed: tests.filter((t) => t.status === 'passed').length,
          'failed-expected': tests.filter((t) => t.status === 'failed' && t.expectedToFail).length,
          'passed-unexpected': tests.filter((t) => t.status === 'passed' && t.expectedToFail)
            .length,
          'failed-unexpected': tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
            .length,
          pending: tests.filter((t) => t.status === 'pending').length,
        }

        const buttonConfigs = [
          { filter: 'all', label: 'All', count: counts.total },
          { filter: 'native', label: 'Native', count: counts.native },
          { filter: 'noble', label: 'Extensibility', count: counts.noble },
          { filter: 'passed', label: 'Passed', count: counts.passed },
          {
            filter: 'failed-expected',
            label: 'Failed (Expected)',
            count: counts['failed-expected'],
          },
          {
            filter: 'passed-unexpected',
            label: 'Passed (Unexpected) âš ï¸',
            count: counts['passed-unexpected'],
            hideIfZero: true,
          },
          {
            filter: 'failed-unexpected',
            label: 'Failed (Unexpected) âš ï¸',
            count: counts['failed-unexpected'],
            hideIfZero: true,
          },
          { filter: 'pending', label: 'Pending', count: counts.pending, hideIfZero: true },
        ]

        buttonConfigs.forEach(({ filter, label, count, hideIfZero }) => {
          const btn = document.querySelector(`[data-filter="${filter}"]`)
          if (!btn) return

          if (hideIfZero && count === 0) {
            btn.style.display = 'none'
          } else {
            btn.style.display = ''
            btn.textContent = `${label} (${count})`
          }
        })
      }

      /** Gets the display name for a test (shows the component being tested) */
      function getTestDisplayName(test) {
        const component = getTestComponent(test)
        return component.displayName || component.name
      }

      /** Renders a single test item as HTML */
      function renderTest(test) {
        const testName = getTestDisplayName(test)

        // Determine status display
        let statusClass = test.status
        let statusText = test.status
        let showStatus = true

        if (test.expectedToFail && test.status === 'failed') {
          // Expected failure - don't show status pill
          statusClass = 'expected'
          statusText = 'expected'
          showStatus = false
        } else if (test.expectedToFail && test.status === 'passed') {
          // Unexpected pass
          statusClass = 'passed-unexpected'
          statusText = 'unexpected pass'
        }

        return `
        <div class="test-item ${statusClass}" data-id="${test.id}" data-status="${test.status}">
          <div class="test-header">
            <div class="test-name">${testName}</div>
            ${
              showStatus
                ? `<div class="test-status ${statusClass}">
              ${test.status === 'running' ? '<span class="loader"></span>' : ''}
              ${statusText}
            </div>`
                : ''
            }
          </div>
          ${test.error ? `<div class="test-error">${escapeHtml(test.error)}</div>` : ''}
        </div>
      `
      }

      /** Escapes HTML characters in text to prevent XSS */
      function escapeHtml(text) {
        const div = document.createElement('div')
        div.textContent = text
        return div.innerHTML
      }

      /** Filters tests based on the current filter setting */
      function getFilteredTests() {
        if (currentFilter === 'all') {
          return tests
        } else if (currentFilter === 'native') {
          return tests.filter((t) => !getTestComponent(t).isNoble)
        } else if (currentFilter === 'noble') {
          return tests.filter((t) => getTestComponent(t).isNoble)
        } else if (currentFilter === 'failed-expected') {
          return tests.filter((t) => t.status === 'failed' && t.expectedToFail)
        } else if (currentFilter === 'failed-unexpected') {
          return tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
        } else if (currentFilter === 'passed-unexpected') {
          return tests.filter((t) => t.status === 'passed' && t.expectedToFail)
        } else {
          return tests.filter((t) => t.status === currentFilter)
        }
      }

      /** Renders the test grid with filtered tests */
      function renderTests() {
        const grid = document.getElementById('testGrid')
        const filteredTests = getFilteredTests()
        grid.innerHTML = filteredTests.map(renderTest).join('')
      }

      // ============================================================================
      // TEST EXECUTION
      // ============================================================================

      /** Performs encryption/decryption test for regular AEAD modes */
      async function testRegularAEAD(suite, recipientKeyPair) {
        const plaintext = new TextEncoder().encode('Hello, HPKE!')
        const aad = new TextEncoder().encode('additional data')

        // Sender seals using recipient's public key
        const { encapsulatedKey, ciphertext } = await suite.Seal(
          recipientKeyPair.publicKey,
          plaintext,
          aad,
        )

        // Recipient opens using their private key
        const decrypted = await suite.Open(recipientKeyPair, encapsulatedKey, ciphertext, aad)

        // Verify decrypted matches plaintext
        const decryptedText = new TextDecoder().decode(decrypted)
        if (decryptedText !== 'Hello, HPKE!') {
          throw new Error(`Decryption mismatch: expected "Hello, HPKE!", got "${decryptedText}"`)
        }
      }

      /** Performs export-only mode test */
      async function testExportOnlyMode(suite, recipientKeyPair) {
        const exporterContext = new TextEncoder().encode('test context')
        const L = 32

        // Sender exports secret using recipient's public key
        const { encapsulatedKey, exportedSecret } = await suite.SendExport(
          recipientKeyPair.publicKey,
          exporterContext,
          L,
        )

        // Recipient receives exported secret using their private key
        const receivedSecret = await suite.ReceiveExport(
          recipientKeyPair,
          encapsulatedKey,
          exporterContext,
          L,
        )

        // Verify the secrets match
        assertUint8ArraysEqual(exportedSecret, receivedSecret, 'Exported secret mismatch')
      }

      /** Helper to find a matching implementation, preferring native over Noble */
      function findMatchingImplementation(algorithms, algorithmId, unsupportedList) {
        // Prefer native implementations that are supported
        return (
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return !a.isNoble && !unsupportedList.includes(a.name)
          }) ||
          // Fall back to Noble implementation
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return a.isNoble
          })
        )
      }

      /** Helper to verify two Uint8Arrays match */
      function assertUint8ArraysEqual(actual, expected, errorPrefix) {
        if (actual.length !== expected.length) {
          throw new Error(`${errorPrefix}: length mismatch`)
        }
        for (let i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) {
            throw new Error(`${errorPrefix}: content mismatch`)
          }
        }
      }

      /** Runs a single test for a KEM/KDF/AEAD combination */
      async function runTest(test) {
        test.status = 'running'
        renderTests()
        updateSummary()
        renderAlgorithmSummary()

        try {
          // Test with baseline components (existing behavior)
          const suite = new HPKE.CipherSuite(test.kem.factory, test.kdf.factory, test.aead.factory)

          // Generate test key pair
          await suite.GenerateKeyPair()
          const ikm = crypto.getRandomValues(new Uint8Array(suite.KEM.Nsk))
          const keyPair = await suite.DeriveKeyPair(ikm, true)

          // Serialize and deserialize keys to test that functionality
          const serializedPublicKey = await suite.SerializePublicKey(keyPair.publicKey)
          const serializedPrivateKey = await suite.SerializePrivateKey(keyPair.privateKey)
          const recipientPrivateKey = await suite.DeserializePrivateKey(serializedPrivateKey, true)
          const recipientPublicKey = await suite.DeserializePublicKey(serializedPublicKey)
          const recipientKeyPair = {
            publicKey: recipientPublicKey,
            privateKey: recipientPrivateKey,
          }

          // Test based on AEAD mode
          if (test.aead.name === 'AEAD_EXPORT_ONLY') {
            await testExportOnlyMode(suite, recipientKeyPair)
          } else {
            await testRegularAEAD(suite, recipientKeyPair)
          }

          test.status = 'passed'
          test.error = null

          // Collect passing implementation
          const component = test.testingComponent
          const componentAlgo = test[component]
          const algoId = ALGORITHM_IDS[componentAlgo.name]

          if (algoId !== undefined) {
            if (!passingImplementations[component].has(algoId)) {
              passingImplementations[component].set(algoId, [])
            }
            passingImplementations[component].get(algoId).push({
              factory: componentAlgo.factory,
              isNoble: componentAlgo.isNoble,
            })
          }
        } catch (error) {
          test.status = 'failed'
          test.error = error.message || String(error)

          // Log unexpected failures to console
          if (!test.expectedToFail) {
            // console.error(`Unexpected failure: ${getTestDisplayName(test)}`, error)
          }
        }

        renderTests()
        updateSummary()
        renderAlgorithmSummary()
      }

      /** Runs all tests */
      async function runAllTests() {
        for (const test of tests) {
          await runTest(test)
          // Small delay to allow UI updates
          await new Promise((resolve) => setTimeout(resolve, 10))
        }

        // Expose results to globalThis after all tests complete
        updateGlobalResults()
      }

      // ============================================================================
      // RESULTS EXPORT
      // ============================================================================

      /** Exposes test results on globalThis for external access */
      function updateGlobalResults() {
        globalThis.hpkeTestResults = {
          total: tests.length,
          passed: tests.filter((t) => t.status === 'passed').length,
          failed: tests.filter((t) => t.status === 'failed').length,
          expectedFailures: tests.filter((t) => t.status === 'failed' && t.expectedToFail).length,
          unexpectedFailures: tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
            .length,
          unexpectedPasses: tests.filter((t) => t.status === 'passed' && t.expectedToFail).length,
          tests: tests.map((t) => {
            const component = getTestComponent(t)
            return {
              id: t.id,
              component: t.testingComponent,
              name: component.displayName || component.name,
              suite: {
                kem: t.kem.displayName || t.kem.name,
                kdf: t.kdf.displayName || t.kdf.name,
                aead: t.aead.displayName || t.aead.name,
              },
              status: t.status,
              expectedToFail: t.expectedToFail,
              error: t.error,
            }
          }),
        }
      }

      // ============================================================================
      // FILTER MANAGEMENT
      // ============================================================================

      /** Sets up filter buttons and loads saved filter preference */
      function setupFilters() {
        // Load saved filter from localStorage
        const savedFilter = localStorage.getItem('hpkeTestFilter')
        if (savedFilter) {
          currentFilter = savedFilter
          // Update active button
          document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
          const activeBtn = document.querySelector(`[data-filter="${savedFilter}"]`)
          if (activeBtn) {
            activeBtn.classList.add('active')
          }
        }

        // Add click handlers to filter buttons
        document.querySelectorAll('.filter-btn').forEach((btn) => {
          btn.addEventListener('click', (e) => {
            document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
            e.target.classList.add('active')
            currentFilter = e.target.dataset.filter
            // Save filter preference to localStorage
            localStorage.setItem('hpkeTestFilter', currentFilter)
            renderTests()
          })
        })
      }

      // ============================================================================
      // INITIALIZATION
      // ============================================================================

      // ============================================================================
      // VECTOR VALIDATION
      // ============================================================================

      /** Runs comprehensive vector validation tests */
      async function runVectorValidation() {
        const vectorSection = document.getElementById('vectorValidation')
        vectorSection.classList.add('running')

        const progressBar = document.getElementById('vectorProgress')
        const progressText = document.getElementById('vectorProgressText')
        const progressInfo = document.getElementById('vectorProgressInfo')

        let completedOps = 0
        let passedOps = 0
        let failedOps = 0
        let totalOps = 0

        // Calculate total operations first
        for (const vector of allVectors) {
          const kemImpls = passingImplementations.kem.get(vector.kem_id) || []
          const kdfImpls = passingImplementations.kdf.get(vector.kdf_id) || []
          const aeadImpls = passingImplementations.aead.get(vector.aead_id) || []

          if (!kemImpls.length || !kdfImpls.length || !aeadImpls.length) continue

          const combinations = kemImpls.length * kdfImpls.length * aeadImpls.length
          totalOps +=
            combinations * ((vector.encryptions?.length || 0) + (vector.exports?.length || 0))
        }

        if (totalOps === 0) {
          progressInfo.innerHTML =
            '<span>No functional implementations found for vector validation</span>'
          vectorSection.classList.remove('running')
          return
        }

        const updateProgress = () => {
          const percent = Math.round((completedOps / totalOps) * 100)
          progressBar.style.width = `${percent}%`
          progressText.textContent = `${percent}%`
          progressInfo.innerHTML = `
            <span>Total: ${totalOps} operations</span>
            <span><span class="passed">âœ“ ${passedOps}</span> <span class="failed">âœ— ${failedOps}</span></span>
          `
        }

        updateProgress()

        // Process all vectors with their implementations
        for (const vector of allVectors) {
          const kemImpls = passingImplementations.kem.get(vector.kem_id) || []
          const kdfImpls = passingImplementations.kdf.get(vector.kdf_id) || []
          const aeadImpls = passingImplementations.aead.get(vector.aead_id) || []

          if (!kemImpls.length || !kdfImpls.length || !aeadImpls.length) continue

          for (const kemImpl of kemImpls) {
            for (const kdfImpl of kdfImpls) {
              for (const aeadImpl of aeadImpls) {
                const suite = new HPKE.CipherSuite(
                  kemImpl.factory,
                  kdfImpl.factory,
                  aeadImpl.factory,
                )
                const ikmR = Uint8Array.fromHex(vector.ikmR)
                const recipientKeyPair = await suite.DeriveKeyPair(ikmR, true)
                const enc = Uint8Array.fromHex(vector.enc)

                const options = {
                  info: Uint8Array.fromHex(vector.info),
                  psk: vector.psk ? Uint8Array.fromHex(vector.psk) : undefined,
                  pskId: vector.psk_id ? Uint8Array.fromHex(vector.psk_id) : undefined,
                }

                const ctx = await suite.SetupRecipient(recipientKeyPair, enc, options)

                // Test all encryptions
                if (vector.encryptions) {
                  for (const encryption of vector.encryptions) {
                    try {
                      const ciphertext = Uint8Array.fromHex(encryption.ct)
                      const aad = Uint8Array.fromHex(encryption.aad)
                      const expectedPlaintext = Uint8Array.fromHex(encryption.pt)
                      const decrypted = await ctx.Open(ciphertext, aad)
                      assertUint8ArraysEqual(decrypted, expectedPlaintext, 'Plaintext mismatch')
                      passedOps++
                    } catch (e) {
                      failedOps++
                    } finally {
                      completedOps++
                      updateProgress()
                    }
                  }
                }

                // Test all exports
                if (vector.exports) {
                  for (const exportTest of vector.exports) {
                    try {
                      const exporterContext = Uint8Array.fromHex(exportTest.exporter_context)
                      const L = exportTest.L
                      const expectedExportedValue = Uint8Array.fromHex(exportTest.exported_value)
                      const exportedValue = await ctx.Export(exporterContext, L)
                      assertUint8ArraysEqual(
                        exportedValue,
                        expectedExportedValue,
                        'Export mismatch',
                      )
                      passedOps++
                    } catch (e) {
                      failedOps++
                    } finally {
                      completedOps++
                      updateProgress()
                    }
                  }
                }

                // Small delay for UI updates
                await new Promise((resolve) => setTimeout(resolve, 0))
              }
            }
          }
        }

        // Final update
        vectorSection.classList.remove('running')
        if (failedOps === 0) {
          vectorSection.classList.add('passed')
          progressBar.classList.remove('failed')
        } else {
          vectorSection.classList.add('failed')
          progressBar.classList.add('failed')
        }
        updateProgress()

        // Add vector results to globalThis
        globalThis.hpkeTestResults.vectorValidation = {
          total: totalOps,
          passed: passedOps,
          failed: failedOps,
        }
      }

      /** Initializes the test suite and starts execution */
      async function init() {
        tests = generateTests()
        renderAlgorithmSummary()
        setupFilters()
        updateSummary()
        renderTests()
        await runAllTests()
        await runVectorValidation()
      }

      init()
    </script>
  </body>
</html>
