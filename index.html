<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@panva/hpke</title>
    <script type="importmap">
      {
        "imports": {
          "@panva/hpke": "./index.js",
          "@panva/hpke-noble": "./examples/noble-suite/index.js",
          "@noble/": "./node_modules/@noble/",
          "./index.ts": "./index.js",
          "bowser": "https://cdn.jsdelivr.net/npm/bowser@2/+esm"
        }
      }
    </script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          sans-serif;
        padding: 20px;
        background: rgb(13, 17, 23);
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgb(22, 27, 34);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        padding: 30px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        gap: 20px;
        position: relative;
      }

      h1 {
        color: #e6edf3;
        margin: 0;
        font-size: 32px;
        line-height: 1;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      h1 a {
        color: #8b949e;
        text-decoration: none;
        font-family: 'Monaco', 'Courier New', monospace;
        display: inline-flex;
        align-items: center;
        transition: color 0.2s ease;
      }

      h1 a:hover {
        color: #58a6ff;
      }

      h1 a svg {
        width: 24px;
        height: 24px;
      }

      .filter-links {
        display: flex;
        gap: 12px;
        font-size: 13px;
        flex-shrink: 0;
      }

      .filter-links a {
        color: #8b949e;
        text-decoration: none;
        padding: 6px 12px;
        border: 2px solid #30363d;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .filter-links a:hover {
        color: #e6edf3;
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .filter-links a#filterNative.active {
        color: #e6edf3;
        border-color: #3fb950;
        background: rgba(46, 160, 67, 0.15);
      }

      .filter-links a#filterNoble.active {
        color: #e6edf3;
        border-color: #388bfd;
        background: rgba(56, 139, 253, 0.15);
      }

      .filter-links a#filterBoth.active {
        color: #e6edf3;
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-width: 2px;
        border-style: solid;
        border-image: linear-gradient(
            135deg,
            #3fb950 0%,
            #3fb950 66.67%,
            #388bfd 66.67%,
            #388bfd 100%
          )
          1;
      }

      .burger-menu {
        display: none;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
        padding: 8px;
        border: 2px solid #30363d;
        background: transparent;
        transition: all 0.2s ease;
      }

      .burger-menu:hover {
        border-color: #58a6ff;
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .burger-menu span {
        width: 20px;
        height: 2px;
        background: #8b949e;
        transition: all 0.2s ease;
      }

      .burger-menu:hover span {
        background: #58a6ff;
      }

      .subtitle {
        color: #8b949e;
        margin-bottom: 30px;
        font-size: 16px;
      }

      .summary {
        margin-bottom: 30px;
      }

      .legend {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        padding: 12px;
        background: rgba(110, 118, 129, 0.1);
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #8b949e;
        transition: all 0.2s ease;
      }

      .legend-item a {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #8b949e;
        text-decoration: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .legend-item a:hover {
        color: #e6edf3;
      }

      .legend-item.disabled {
        opacity: 0.5;
      }

      .legend-item.disabled span {
        text-decoration: line-through;
        color: #6e7681;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border: 2px solid;
      }

      .legend-color.native {
        background: rgba(46, 160, 67, 0.15);
        border-color: #3fb950;
      }

      .legend-color.noble {
        background: rgba(56, 139, 253, 0.15);
        border-color: #388bfd;
      }

      .legend-color.both {
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 50%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-color: #3fb950;
        border-image: linear-gradient(135deg, #3fb950 0%, #3fb950 50%, #388bfd 50%, #388bfd 100%) 1;
      }

      .legend-color.unsupported {
        background: rgba(248, 81, 73, 0.15);
        border-color: #f85149;
      }

      .algorithm-section {
        margin-bottom: 25px;
      }

      .algorithm-section h3 {
        font-size: 18px;
        color: #e6edf3;
        margin-bottom: 12px;
        font-weight: 600;
      }

      .algorithm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
      }

      .algo-card {
        padding: 12px;
        border: 2px solid;
        font-size: 13px;
        font-family: 'Monaco', 'Courier New', monospace;
        transition: all 0.2s ease;
      }

      .algo-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .algo-card.native {
        background: rgba(46, 160, 67, 0.15);
        border-color: #3fb950;
        color: #e6edf3;
      }

      .algo-card.noble {
        background: rgba(56, 139, 253, 0.15);
        border-color: #388bfd;
        color: #e6edf3;
      }

      .algo-card.both {
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-color: #3fb950;
        border-width: 2px;
        border-style: solid;
        border-image: linear-gradient(
            135deg,
            #3fb950 0%,
            #3fb950 66.67%,
            #388bfd 66.67%,
            #388bfd 100%
          )
          1;
        color: #e6edf3;
      }

      .algo-card.unsupported {
        background: rgba(248, 81, 73, 0.15);
        border-color: #f85149;
        color: #e6edf3;
      }

      .algo-card.pending {
        background: rgba(110, 118, 129, 0.1);
        border-color: #30363d;
        color: #e6edf3;
      }

      .algo-card.testing {
        background: rgba(187, 128, 9, 0.15);
        border-color: #bb8009;
        color: #e6edf3;
      }

      .algo-card {
        position: relative;
      }

      .algo-card .algo-name {
        font-weight: 600;
        word-break: break-word;
      }

      .vector-validation {
        margin-bottom: 30px;
        padding: 20px;
        background: rgb(13, 17, 23);
        border: 2px solid #30363d;
        transition: all 0.2s ease;
      }

      .vector-validation.running {
        border-color: #bb8009;
        background: rgba(187, 128, 9, 0.15);
      }

      .vector-validation.passed-native {
        border-color: #3fb950;
        background: rgba(46, 160, 67, 0.15);
      }

      .vector-validation.passed-noble {
        border-color: #388bfd;
        background: rgba(56, 139, 253, 0.15);
      }

      .vector-validation.passed-both {
        background: linear-gradient(
          135deg,
          rgba(46, 160, 67, 0.15) 0%,
          rgba(46, 160, 67, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 66.67%,
          rgba(56, 139, 253, 0.15) 100%
        );
        border-width: 2px;
        border-style: solid;
        border-image: linear-gradient(
            135deg,
            #3fb950 0%,
            #3fb950 66.67%,
            #388bfd 66.67%,
            #388bfd 100%
          )
          1;
      }

      .vector-validation.failed {
        border-color: #f85149;
        background: rgba(248, 81, 73, 0.15);
      }

      .vector-validation h3 {
        font-size: 18px;
        color: #e6edf3;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .vector-validation .subtitle-text {
        font-size: 13px;
        color: #8b949e;
        margin-bottom: 15px;
      }

      .progress-bar-container {
        background: rgb(22, 27, 34);
        height: 24px;
        margin-bottom: 10px;
        position: relative;
        display: flex;
        gap: 2px;
        padding: 2px;
      }

      .progress-box {
        flex: 1;
        background: rgba(48, 54, 61, 0.5);
      }

      .progress-box.filled {
        background: #3fb950;
      }

      .progress-box.filled.failed {
        background: #f85149;
      }

      .progress-info {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: #8b949e;
        font-family: 'Monaco', 'Courier New', monospace;
      }

      .progress-info .passed {
        color: #7ee787;
      }

      .progress-info .failed {
        color: #ff7b72;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 15px;
          display: flex;
          flex-direction: column;
        }

        .header {
          flex-wrap: wrap;
          order: 1;
        }

        h1 {
          font-size: 24px;
          flex: 1;
        }

        .burger-menu {
          display: flex;
        }

        .filter-links {
          display: none;
          flex-direction: column;
          width: 100%;
          order: 3;
        }

        .filter-links.open {
          display: flex;
        }

        .filter-links a {
          text-align: center;
        }

        .subtitle {
          order: 2;
        }

        .legend {
          order: 3;
        }

        .vector-validation {
          order: 4;
        }

        .vector-validation .progress-bar-container {
          order: -1;
          margin-bottom: 15px;
        }

        .summary {
          order: 5;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>
          @panva/hpke
          <a href="https://github.com/panva/hpke" target="_blank">
            <svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              ></path>
            </svg>
          </a>
          <a href="https://www.npmjs.com/package/@panva/hpke" target="_blank">
            <svg viewBox="0 0 780 250" fill="currentColor" aria-hidden="true">
              <path
                d="M240,250h100v-50h100V0H240V250z M340,50h50v100h-50V50z M480,0v200h100V50h50v150h50V50h50v150h50V0H480z M0,200h100V50h50v150h50V0H0V200z"
              ></path>
            </svg>
          </a>
        </h1>
        <button class="burger-menu" id="burgerMenu" aria-label="Toggle menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
        <div class="filter-links" id="filterLinks">
          <a href="?native" id="filterNative">Native</a>
          <a href="?noble" id="filterNoble">Extensibility</a>
          <a href="./" id="filterBoth">Both</a>
        </div>
      </div>
      <p class="subtitle">Test suite for all KEM, KDF, and AEAD implementations in your browser</p>

      <div class="legend">
        <div class="legend-item" id="legendNative">
          <a href="?native">
            <div class="legend-color native"></div>
            <span>Native (Web Cryptography)</span>
          </a>
        </div>
        <div class="legend-item" id="legendNoble">
          <a href="?noble">
            <div class="legend-color noble"></div>
            <span>Extensibility (Noble Cryptography)</span>
          </a>
        </div>
        <div class="legend-item" id="legendBoth">
          <a href="./">
            <div class="legend-color both"></div>
            <span>Both implementations</span>
          </a>
        </div>
        <div class="legend-item">
          <div class="legend-color unsupported"></div>
          <span>Unsupported</span>
        </div>
      </div>

      <div class="summary" id="summary"></div>

      <div class="vector-validation" id="vectorValidation">
        <h3>Test Vector Validation</h3>
        <p class="subtitle-text">
          Testing all encryptions and exports from RFC test vectors with functional implementations
        </p>
        <div class="progress-bar-container" id="vectorProgressContainer">
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
          <div class="progress-box"></div>
        </div>
        <div class="progress-info" id="vectorProgressInfo">
          <span>Pending...</span>
        </div>
      </div>
    </div>

    <script type="module">
      // Check query string parameters to filter implementations
      const params = new URLSearchParams(window.location.search)
      const onlyNative = params.has('native')
      const onlyNoble = params.has('noble')
      const both = (onlyNative && onlyNoble) || (!onlyNative && !onlyNoble)

      // Highlight active filter link
      if (onlyNative) {
        document.getElementById('filterNative').classList.add('active')
        document.getElementById('legendNoble').classList.add('disabled')
        document.getElementById('legendBoth').classList.add('disabled')
      } else if (onlyNoble) {
        document.getElementById('filterNoble').classList.add('active')
        document.getElementById('legendNative').classList.add('disabled')
        document.getElementById('legendBoth').classList.add('disabled')
      } else {
        document.getElementById('filterBoth').classList.add('active')
      }

      import * as HPKE from '@panva/hpke'
      import * as Noble from '@panva/hpke-noble'
      import Bowser from 'bowser'

      import vectors from './test/vectors.json' with { type: 'json' }
      import vectorsPq from './test/vectors-pq.json' with { type: 'json' }
      const allVectors = [...vectors, ...vectorsPq].filter((v) => {
        if (v.mode !== 0x00 && v.mode !== 0x01) return false
        return true
      })

      // ============================================================================
      // ALGORITHM DISCOVERY
      // ============================================================================
      // Dynamically extract all algorithms from HPKE and Noble libraries based on
      // name prefixes (KEM_, KDF_, AEAD_)

      /** Extracts algorithms from a library object by prefix */
      function extractAlgorithms(library, prefix, label, isNoble = false) {
        return Object.keys(library)
          .filter((key) => key.startsWith(prefix))
          .map((name) => ({
            name,
            displayName: `[${label}] ${name}`,
            factory: library[name],
            isNoble,
          }))
          .sort((a, b) => a.name.localeCompare(b.name))
      }

      // Extract native HPKE algorithms
      const KEMS = extractAlgorithms(HPKE, 'KEM_', 'native')
      const KDFS = extractAlgorithms(HPKE, 'KDF_', 'native')
      const AEADS = extractAlgorithms(HPKE, 'AEAD_', 'native')

      // Extract Noble (extensibility) algorithms
      const NOBLE_KEMS = extractAlgorithms(Noble, 'KEM_', 'extensibility', true)
      const NOBLE_KDFS = extractAlgorithms(Noble, 'KDF_', 'extensibility', true)
      const NOBLE_AEADS = extractAlgorithms(Noble, 'AEAD_', 'extensibility', true)

      // Burger menu toggle
      document.getElementById('burgerMenu').addEventListener('click', () => {
        document.getElementById('filterLinks').classList.toggle('open')
      })

      // Combine native and Noble implementations based on query params
      const ALL_KEMS = both ? KEMS.concat(NOBLE_KEMS) : onlyNative ? KEMS : NOBLE_KEMS
      const ALL_KDFS = both ? KDFS.concat(NOBLE_KDFS) : onlyNative ? KDFS : NOBLE_KDFS
      const ALL_AEADS = both ? AEADS.concat(NOBLE_AEADS) : onlyNative ? AEADS : NOBLE_AEADS

      // ============================================================================
      // ALGORITHM ID MAPPINGS
      // ============================================================================
      // Static mapping of algorithm names to their IDs from the HPKE specification

      const ALGORITHM_IDS = {
        // KEMs
        KEM_DHKEM_P256_HKDF_SHA256: 0x0010,
        KEM_DHKEM_P384_HKDF_SHA384: 0x0011,
        KEM_DHKEM_P521_HKDF_SHA512: 0x0012,
        KEM_DHKEM_X25519_HKDF_SHA256: 0x0020,
        KEM_DHKEM_X448_HKDF_SHA512: 0x0021,
        KEM_ML_KEM_512: 0x0040,
        KEM_ML_KEM_768: 0x0041,
        KEM_ML_KEM_1024: 0x0042,
        KEM_MLKEM768_P256: 0x0050,
        KEM_MLKEM1024_P384: 0x0051,
        KEM_MLKEM768_X25519: 0x647a,

        // KDFs
        KDF_HKDF_SHA256: 0x0001,
        KDF_HKDF_SHA384: 0x0002,
        KDF_HKDF_SHA512: 0x0003,
        KDF_SHAKE128: 0x0010,
        KDF_SHAKE256: 0x0011,
        KDF_TurboSHAKE128: 0x0012,
        KDF_TurboSHAKE256: 0x0013,

        // AEADs
        AEAD_AES_128_GCM: 0x0001,
        AEAD_AES_256_GCM: 0x0002,
        AEAD_ChaCha20Poly1305: 0x0003,
        AEAD_EXPORT_ONLY: 0xffff,
      }

      // Mapping of algorithm names to their display names
      const ALGORITHM_NAMES = {
        // KEMs
        KEM_DHKEM_P256_HKDF_SHA256: 'DHKEM(P-256, HKDF-SHA256)',
        KEM_DHKEM_P384_HKDF_SHA384: 'DHKEM(P-384, HKDF-SHA384)',
        KEM_DHKEM_P521_HKDF_SHA512: 'DHKEM(P-521, HKDF-SHA512)',
        KEM_DHKEM_X25519_HKDF_SHA256: 'DHKEM(X25519, HKDF-SHA256)',
        KEM_DHKEM_X448_HKDF_SHA512: 'DHKEM(X448, HKDF-SHA512)',
        KEM_ML_KEM_512: 'ML-KEM-512',
        KEM_ML_KEM_768: 'ML-KEM-768',
        KEM_ML_KEM_1024: 'ML-KEM-1024',
        KEM_MLKEM768_P256: 'MLKEM768-P256',
        KEM_MLKEM1024_P384: 'MLKEM1024-P384',
        KEM_MLKEM768_X25519: 'MLKEM768-X25519',

        // KDFs
        KDF_HKDF_SHA256: 'HKDF-SHA256',
        KDF_HKDF_SHA384: 'HKDF-SHA384',
        KDF_HKDF_SHA512: 'HKDF-SHA512',
        KDF_SHAKE128: 'SHAKE128',
        KDF_SHAKE256: 'SHAKE256',
        KDF_TurboSHAKE128: 'TurboSHAKE128',
        KDF_TurboSHAKE256: 'TurboSHAKE256',

        // AEADs
        AEAD_AES_128_GCM: 'AES-128-GCM',
        AEAD_AES_256_GCM: 'AES-256-GCM',
        AEAD_ChaCha20Poly1305: 'ChaCha20Poly1305',
        AEAD_EXPORT_ONLY: 'Export-only',
      }

      // Validate that all algorithms have IDs and names in the maps
      const allAlgorithms = [
        ...KEMS,
        ...KDFS,
        ...AEADS,
        ...NOBLE_KEMS,
        ...NOBLE_KDFS,
        ...NOBLE_AEADS,
      ]
      const missingIds = []
      const missingNames = []

      for (const algo of allAlgorithms) {
        if (!(algo.name in ALGORITHM_IDS)) {
          missingIds.push(algo.name)
        }
        if (!(algo.name in ALGORITHM_NAMES)) {
          missingNames.push(algo.name)
        }
      }

      if (missingIds.length > 0 || missingNames.length > 0) {
        const errors = []
        if (missingIds.length > 0) {
          errors.push(`Missing ALGORITHM_IDS entries: ${missingIds.join(', ')}`)
        }
        if (missingNames.length > 0) {
          errors.push(`Missing ALGORITHM_NAMES entries: ${missingNames.join(', ')}`)
        }
        throw new Error(`Configuration Error:\n${errors.join('\n')}`)
      }

      // ============================================================================
      // BASELINE CONFIGURATION
      // ============================================================================
      // When testing a specific component (e.g., a KEM), we pair it with baseline
      // KDF and AEAD to isolate the test. These are the baseline algorithms.

      const baselineKEM = KEMS.find((k) => k.name === 'KEM_DHKEM_P256_HKDF_SHA256')
      const baselineKDF = KDFS.find((k) => k.name === 'KDF_HKDF_SHA256')
      const baselineAEAD = AEADS.find((a) => a.name === 'AEAD_AES_128_GCM')

      // ============================================================================
      // BROWSER COMPATIBILITY
      // ============================================================================
      // Some algorithms are not supported in browsers due to missing Web Crypto APIs
      // Noble implementations provide fallbacks for these
      // Browser-specific unsupported algorithms based on Web Crypto API availability

      /** Detects the current browser engine and version */
      function detectBrowser() {
        const browser = Bowser.getParser(navigator.userAgent)
        return {
          engine: browser.getEngineName(),
          version: parseInt(browser.getBrowserVersion()),
        }
      }

      const unsupported = {
        kem: [
          'KEM_DHKEM_X448_HKDF_SHA512',
          'KEM_ML_KEM_512',
          'KEM_ML_KEM_768',
          'KEM_ML_KEM_1024',
          'KEM_MLKEM768_X25519',
          'KEM_MLKEM768_P256',
          'KEM_MLKEM1024_P384',
        ],
        kdf: ['KDF_SHAKE128', 'KDF_SHAKE256'],
        aead: ['AEAD_ChaCha20Poly1305'],
      }

      const browser = detectBrowser()

      switch (true) {
        case browser.engine === 'Gecko' && browser.version < 143:
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1932396
          unsupported.kem.push('KEM_DHKEM_X25519_HKDF_SHA256')
          break
      }

      /**
       * Determines if a test is expected to fail based on browser support Noble implementations are
       * always expected to work (they provide fallbacks)
       */
      function isExpectedToFail(test) {
        // Noble implementations are always expected to pass (they provide fallbacks)
        if (test.testingComponent === 'kem' && test.kem.isNoble) return false
        if (test.testingComponent === 'kdf' && test.kdf.isNoble) return false
        if (test.testingComponent === 'aead' && test.aead.isNoble) return false

        // Check if the component being tested is unsupported in current browser
        const componentName = test[test.testingComponent].name
        return unsupported[test.testingComponent].includes(componentName)
      }

      // ============================================================================
      // STATE MANAGEMENT
      // ============================================================================

      let tests = []

      // Track passing implementations by algorithm ID
      const passingImplementations = {
        kem: new Map(), // id -> [factories]
        kdf: new Map(), // id -> [factories]
        aead: new Map(), // id -> [factories]
      }

      // ============================================================================
      // TEST GENERATION
      // ============================================================================

      /**
       * Generates the full test suite Strategy: Test each component individually with baseline
       * values for others This avoids testing every combination (which would be thousands of
       * tests)
       */
      function generateTests() {
        const testList = []

        const testConfigs = [
          {
            algorithms: ALL_KEMS,
            component: 'kem',
            baselines: { kdf: baselineKDF, aead: baselineAEAD },
          },
          {
            algorithms: ALL_KDFS,
            component: 'kdf',
            baselines: { kem: baselineKEM, aead: baselineAEAD },
          },
          {
            algorithms: ALL_AEADS,
            component: 'aead',
            baselines: { kem: baselineKEM, kdf: baselineKDF },
          },
        ]

        for (const { algorithms, component, baselines } of testConfigs) {
          for (const algorithm of algorithms) {
            const test = {
              id: testList.length,
              ...baselines,
              [component]: algorithm,
              testingComponent: component,
              status: 'pending',
              error: null,
            }
            test.expectedToFail = isExpectedToFail(test)
            testList.push(test)
          }
        }

        return testList
      }

      // ============================================================================
      // UI RENDERING FUNCTIONS
      // ============================================================================

      /** Gets the component object from a test based on the test's component type */
      function getTestComponent(test) {
        return test.testingComponent === 'kem'
          ? test.kem
          : test.testingComponent === 'kdf'
            ? test.kdf
            : test.aead
      }

      /** Determines the display status for an algorithm card */
      function getAlgorithmStatus(algoName, algoType) {
        // Find ALL tests for this algorithm (native and extensibility)
        const relatedTests = tests.filter((t) => {
          const component = getTestComponent(t)
          return component.name === algoName && t.testingComponent === algoType
        })

        if (relatedTests.length === 0) {
          return 'pending'
        }

        // Check if any test is running
        if (relatedTests.some((t) => t.status === 'running')) {
          return 'testing'
        }

        // Check if any test is still pending
        if (relatedTests.some((t) => t.status === 'pending')) {
          return 'pending'
        }

        // Priority: native passed > noble passed > unsupported
        const nativeTest = relatedTests.find((t) => !getTestComponent(t).isNoble)
        const nobleTest = relatedTests.find((t) => getTestComponent(t).isNoble)

        const nativePassed = nativeTest && nativeTest.status === 'passed'
        const noblePassed = nobleTest && nobleTest.status === 'passed'

        // If both native and noble tests passed, show as both
        if (nativePassed && noblePassed) {
          return 'both'
        }

        // If native test passed, show as native
        if (nativePassed) {
          return 'native'
        }

        // If noble test passed, show as noble
        if (noblePassed) {
          return 'noble'
        }

        // Both failed or no passing tests
        return 'unsupported'
      }

      /**
       * Renders the algorithm summary cards at the top of the page Shows the status of each KEM,
       * KDF, and AEAD algorithm
       */
      function renderAlgorithmSummary() {
        const summaryDiv = document.getElementById('summary')

        // Get unique algorithm names
        const kemNames = [...new Set(ALL_KEMS.map((k) => k.name))].sort()
        const kdfNames = [...new Set(ALL_KDFS.map((k) => k.name))].sort()
        const aeadNames = [...new Set(ALL_AEADS.map((a) => a.name))].sort()

        // Categorize KEMs
        const traditionalKEMs = kemNames
          .filter((name) => name.startsWith('KEM_DHKEM_'))
          .sort((a, b) => {
            // Custom sort: P-256, X25519, P-384, P-521, X448
            const order = [
              'KEM_DHKEM_P256_HKDF_SHA256',
              'KEM_DHKEM_X25519_HKDF_SHA256',
              'KEM_DHKEM_P384_HKDF_SHA384',
              'KEM_DHKEM_P521_HKDF_SHA512',
              'KEM_DHKEM_X448_HKDF_SHA512',
            ]
            return order.indexOf(a) - order.indexOf(b)
          })
        const postQuantumKEMs = kemNames
          .filter((name) => name.startsWith('KEM_ML_KEM_'))
          .sort((a, b) => {
            // Sort ML-KEM by security level: 512, 768, 1024
            const getLevel = (name) => parseInt(name.match(/\d+$/)?.[0] || '0')
            return getLevel(a) - getLevel(b)
          })
        const hybridKEMs = kemNames
          .filter((name) => name.startsWith('KEM_MLKEM'))
          .sort((a, b) => {
            // Custom sort: MLKEM768-P256, MLKEM768-X25519, MLKEM1024-P384
            const order = ['KEM_MLKEM768_P256', 'KEM_MLKEM768_X25519', 'KEM_MLKEM1024_P384']
            return order.indexOf(a) - order.indexOf(b)
          })

        const sections = [
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Traditional (T)',
            algos: traditionalKEMs,
            type: 'kem',
          },
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Hybrid (PQ/T)',
            algos: hybridKEMs,
            type: 'kem',
          },
          {
            title: 'Key Encapsulation Mechanisms (KEM) - Post-Quantum (PQ)',
            algos: postQuantumKEMs,
            type: 'kem',
          },
          { title: 'Key Derivation Functions (KDF)', algos: kdfNames, type: 'kdf' },
          { title: 'Authenticated Encryption (AEAD)', algos: aeadNames, type: 'aead' },
        ]

        summaryDiv.innerHTML = sections
          .map(
            (section) => `
        <div class="algorithm-section">
          <h3>${section.title}</h3>
          <div class="algorithm-grid">
            ${section.algos
              .map((algoName) => {
                const status = getAlgorithmStatus(algoName, section.type)
                const displayName = ALGORITHM_NAMES[algoName]

                return (
                  '<div class="algo-card ' +
                  status +
                  '" data-algo="' +
                  algoName +
                  '" data-type="' +
                  section.type +
                  '">' +
                  '<div class="algo-name">' +
                  displayName +
                  '</div>' +
                  '</div>'
                )
              })
              .join('')}
          </div>
        </div>
      `,
          )
          .join('')
      }

      // ============================================================================
      // TEST EXECUTION
      // ============================================================================

      /** Performs encryption/decryption test for regular AEAD modes */
      async function testRegularAEAD(suite, recipientKeyPair) {
        const plaintext = new TextEncoder().encode('Hello, HPKE!')
        const aad = new TextEncoder().encode('additional data')

        // Sender seals using recipient's public key
        const { encapsulatedKey, ciphertext } = await suite.Seal(
          recipientKeyPair.publicKey,
          plaintext,
          aad,
        )

        // Recipient opens using their private key
        const decrypted = await suite.Open(recipientKeyPair, encapsulatedKey, ciphertext, aad)

        // Verify decrypted matches plaintext
        const decryptedText = new TextDecoder().decode(decrypted)
        if (decryptedText !== 'Hello, HPKE!') {
          throw new Error(`Decryption mismatch: expected "Hello, HPKE!", got "${decryptedText}"`)
        }
      }

      /** Performs export-only mode test */
      async function testExportOnlyMode(suite, recipientKeyPair) {
        const exporterContext = new TextEncoder().encode('test context')
        const L = 32

        // Sender exports secret using recipient's public key
        const { encapsulatedKey, exportedSecret } = await suite.SendExport(
          recipientKeyPair.publicKey,
          exporterContext,
          L,
        )

        // Recipient receives exported secret using their private key
        const receivedSecret = await suite.ReceiveExport(
          recipientKeyPair,
          encapsulatedKey,
          exporterContext,
          L,
        )

        // Verify the secrets match
        assertUint8ArraysEqual(exportedSecret, receivedSecret, 'Exported secret mismatch')
      }

      /** Helper to find a matching implementation, preferring native over Noble */
      function findMatchingImplementation(algorithms, algorithmId, unsupportedList) {
        // Prefer native implementations that are supported
        return (
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return !a.isNoble && !unsupportedList.includes(a.name)
          }) ||
          // Fall back to Noble implementation
          algorithms.find((a) => {
            if (ALGORITHM_IDS[a.name] !== algorithmId) return false
            return a.isNoble
          })
        )
      }

      /** Helper to verify two Uint8Arrays match */
      function assertUint8ArraysEqual(actual, expected, errorPrefix) {
        if (actual.length !== expected.length) {
          throw new Error(`${errorPrefix}: length mismatch`)
        }
        for (let i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) {
            throw new Error(`${errorPrefix}: content mismatch`)
          }
        }
      }

      /** Runs a single test for a KEM/KDF/AEAD combination */
      async function runTest(test) {
        test.status = 'running'
        renderAlgorithmSummary()

        try {
          // Test with baseline components (existing behavior)
          const suite = new HPKE.CipherSuite(test.kem.factory, test.kdf.factory, test.aead.factory)

          // Generate test key pair
          await suite.GenerateKeyPair()
          const ikm = crypto.getRandomValues(new Uint8Array(suite.KEM.Nsk))
          const keyPair = await suite.DeriveKeyPair(ikm, true)

          // Serialize and deserialize keys to test that functionality
          const serializedPublicKey = await suite.SerializePublicKey(keyPair.publicKey)
          const serializedPrivateKey = await suite.SerializePrivateKey(keyPair.privateKey)
          const recipientPrivateKey = await suite.DeserializePrivateKey(serializedPrivateKey, true)
          const recipientPublicKey = await suite.DeserializePublicKey(serializedPublicKey)
          const recipientKeyPair = {
            publicKey: recipientPublicKey,
            privateKey: recipientPrivateKey,
          }

          // Test based on AEAD mode
          if (test.aead.name === 'AEAD_EXPORT_ONLY') {
            await testExportOnlyMode(suite, recipientKeyPair)
          } else {
            await testRegularAEAD(suite, recipientKeyPair)
          }

          test.status = 'passed'
          test.error = null

          // Collect passing implementation
          const component = test.testingComponent
          const componentAlgo = test[component]
          const algoId = ALGORITHM_IDS[componentAlgo.name]

          if (algoId !== undefined) {
            if (!passingImplementations[component].has(algoId)) {
              passingImplementations[component].set(algoId, [])
            }
            passingImplementations[component].get(algoId).push({
              factory: componentAlgo.factory,
              isNoble: componentAlgo.isNoble,
            })
          }
        } catch (error) {
          test.status = 'failed'
          test.error = error.message || String(error)

          // Log unexpected failures to console
          if (!test.expectedToFail) {
            // console.error(`Unexpected failure: ${getTestDisplayName(test)}`, error)
          }
        }

        renderAlgorithmSummary()
      }

      /** Runs all tests */
      async function runAllTests() {
        for (const test of tests) {
          await runTest(test)
          // Small delay to allow UI updates
          await new Promise((resolve) => setTimeout(resolve, 10))
        }

        // Expose results to globalThis after all tests complete
        updateGlobalResults()
      }

      // ============================================================================
      // RESULTS EXPORT
      // ============================================================================

      /** Exposes test results on globalThis for external access */
      function updateGlobalResults() {
        globalThis.hpkeTestResults = {
          total: tests.length,
          passed: tests.filter((t) => t.status === 'passed').length,
          failed: tests.filter((t) => t.status === 'failed').length,
          expectedFailures: tests.filter((t) => t.status === 'failed' && t.expectedToFail).length,
          unexpectedFailures: tests.filter((t) => t.status === 'failed' && !t.expectedToFail)
            .length,
          unexpectedPasses: tests.filter((t) => t.status === 'passed' && t.expectedToFail).length,
          tests: tests.map((t) => {
            const component = getTestComponent(t)
            return {
              id: t.id,
              component: t.testingComponent,
              name: component.displayName || component.name,
              suite: {
                kem: t.kem.displayName || t.kem.name,
                kdf: t.kdf.displayName || t.kdf.name,
                aead: t.aead.displayName || t.aead.name,
              },
              status: t.status,
              expectedToFail: t.expectedToFail,
              error: t.error,
            }
          }),
        }
      }

      // ============================================================================
      // INITIALIZATION
      // ============================================================================

      // ============================================================================
      // VECTOR VALIDATION
      // ============================================================================

      /** Runs comprehensive vector validation tests */
      async function runVectorValidation() {
        const vectorSection = document.getElementById('vectorValidation')
        vectorSection.classList.add('running')

        const progressBar = document.getElementById('vectorProgress')
        const progressText = document.getElementById('vectorProgressText')
        const progressInfo = document.getElementById('vectorProgressInfo')

        let completedOps = 0
        let passedOps = 0
        let failedOps = 0
        let totalOps = 0
        let lastFailedBox = -1

        // Calculate total operations first
        for (const vector of allVectors) {
          const kemImpls = passingImplementations.kem.get(vector.kem_id) || []
          const kdfImpls = passingImplementations.kdf.get(vector.kdf_id) || []
          const aeadImpls = passingImplementations.aead.get(vector.aead_id) || []

          if (!kemImpls.length || !kdfImpls.length || !aeadImpls.length) continue

          const combinations = kemImpls.length * kdfImpls.length * aeadImpls.length
          totalOps +=
            combinations * ((vector.encryptions?.length || 0) + (vector.exports?.length || 0))
        }

        if (totalOps === 0) {
          progressInfo.innerHTML =
            '<span>No functional implementations found for vector validation</span>'
          vectorSection.classList.remove('running')
          return
        }

        const updateProgress = () => {
          const percent = (completedOps / totalOps) * 100
          const filledBoxes = Math.floor(percent / 5)

          const boxes = document.querySelectorAll('.progress-box')
          boxes.forEach((box, index) => {
            const shouldBeFilled = index < filledBoxes
            const isFilled = box.classList.contains('filled')

            // Only modify classes if state changed
            if (shouldBeFilled && !isFilled) {
              box.classList.add('filled')
            } else if (!shouldBeFilled && isFilled) {
              box.classList.remove('filled', 'failed')
            }
          })

          // Mark the box corresponding to when the first failure occurred
          if (failedOps > 0 && lastFailedBox === -1) {
            lastFailedBox = Math.max(0, filledBoxes - 1)
          }
          if (lastFailedBox >= 0 && lastFailedBox < boxes.length) {
            const failedBox = boxes[lastFailedBox]
            if (!failedBox.classList.contains('failed')) {
              failedBox.classList.add('failed')
            }
          }

          progressInfo.innerHTML = `
            <span>Total: ${totalOps} operations</span>
            <span><span class="passed">✓ ${passedOps}</span> <span class="failed">✗ ${failedOps}</span></span>
          `
        }

        updateProgress()

        // Update progress every 50ms during execution
        const progressInterval = setInterval(() => updateProgress(), 50)

        // Cache for recipient key pairs: Map<kemImpl, Map<ikmR_hex, keyPair>>
        const recipientKeyPairCache = new Map()

        // Process all vectors with their implementations
        for (const vector of allVectors) {
          const kemImpls = passingImplementations.kem.get(vector.kem_id) || []
          const kdfImpls = passingImplementations.kdf.get(vector.kdf_id) || []
          const aeadImpls = passingImplementations.aead.get(vector.aead_id) || []

          if (!kemImpls.length || !kdfImpls.length || !aeadImpls.length) continue

          for (const kemImpl of kemImpls) {
            for (const kdfImpl of kdfImpls) {
              for (const aeadImpl of aeadImpls) {
                const suite = new HPKE.CipherSuite(
                  kemImpl.factory,
                  kdfImpl.factory,
                  aeadImpl.factory,
                )
                const ikmR = Uint8Array.fromHex(vector.ikmR)

                // Check cache for this kemImpl and ikmR combination
                if (!recipientKeyPairCache.has(kemImpl)) {
                  recipientKeyPairCache.set(kemImpl, new Map())
                }
                const kemCache = recipientKeyPairCache.get(kemImpl)

                let recipientKeyPair
                if (kemCache.has(vector.ikmR)) {
                  recipientKeyPair = kemCache.get(vector.ikmR)
                } else {
                  recipientKeyPair = await suite.DeriveKeyPair(ikmR, true)
                  kemCache.set(vector.ikmR, recipientKeyPair)
                }
                const enc = Uint8Array.fromHex(vector.enc)

                const options = {
                  info: Uint8Array.fromHex(vector.info),
                  psk: vector.psk ? Uint8Array.fromHex(vector.psk) : undefined,
                  pskId: vector.psk_id ? Uint8Array.fromHex(vector.psk_id) : undefined,
                }

                const ctx = await suite.SetupRecipient(recipientKeyPair, enc, options)

                // Test all encryptions
                if (vector.encryptions) {
                  for (const encryption of vector.encryptions) {
                    try {
                      const ciphertext = Uint8Array.fromHex(encryption.ct)
                      const aad = Uint8Array.fromHex(encryption.aad)
                      const expectedPlaintext = Uint8Array.fromHex(encryption.pt)
                      const decrypted = await ctx.Open(ciphertext, aad)
                      assertUint8ArraysEqual(decrypted, expectedPlaintext, 'Plaintext mismatch')
                      passedOps++
                    } catch (e) {
                      failedOps++
                    } finally {
                      completedOps++
                    }
                  }
                }

                // Test all exports
                if (vector.exports) {
                  for (const exportTest of vector.exports) {
                    try {
                      const exporterContext = Uint8Array.fromHex(exportTest.exporter_context)
                      const L = exportTest.L
                      const expectedExportedValue = Uint8Array.fromHex(exportTest.exported_value)
                      const exportedValue = await ctx.Export(exporterContext, L)
                      assertUint8ArraysEqual(
                        exportedValue,
                        expectedExportedValue,
                        'Export mismatch',
                      )
                      passedOps++
                    } catch (e) {
                      failedOps++
                    } finally {
                      completedOps++
                    }
                  }
                }

                updateProgress()
                // Yield to event loop to allow UI updates
                await new Promise((resolve) => setTimeout(resolve, 0))
              }
            }
          }
        }

        // Final update
        clearInterval(progressInterval)
        updateProgress()
        vectorSection.classList.remove('running')
        if (failedOps === 0) {
          if (onlyNative) {
            vectorSection.classList.add('passed-native')
          } else if (onlyNoble) {
            vectorSection.classList.add('passed-noble')
          } else {
            vectorSection.classList.add('passed-both')
          }
        } else {
          vectorSection.classList.add('failed')
        }
        updateProgress()

        // Add vector results to globalThis
        globalThis.hpkeTestResults.vectorValidation = {
          total: totalOps,
          passed: passedOps,
          failed: failedOps,
        }
      }

      /** Initializes the test suite and starts execution */
      async function init() {
        tests = generateTests()
        renderAlgorithmSummary()
        await runAllTests()
        await runVectorValidation()
      }

      init()
    </script>
  </body>
</html>
